
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>numericalFunctions Package &mdash; Fudge and GND 1.2 beta documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2 beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/gnd-20121206-favicon.ico"/>
    <link rel="top" title="Fudge and GND 1.2 beta documentation" href="../index.html" />
    <link rel="up" title="fudge Package" href="index.html" />
    <link rel="next" title="crossSectionAdjustForHeatedTarget Package" href="crossSectionAdjustForHeatedTarget.html" />
    <link rel="prev" title="test Package" href="pqu.test.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="crossSectionAdjustForHeatedTarget.html" title="crossSectionAdjustForHeatedTarget Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pqu.test.html" title="test Package"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Fudge and GND 1.2 beta documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">fudge Package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="numericalfunctions-package">
<h1>numericalFunctions Package<a class="headerlink" href="#numericalfunctions-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-numericalFunctions.lib.nf_specialFunctions_C">
<span id="specialfunctions-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">specialFunctions</span></tt> Module<a class="headerlink" href="#module-numericalFunctions.lib.nf_specialFunctions_C" title="Permalink to this headline">¶</a></h2>
<p>A module that contains special math functions not in the python math module.</p>
<dl class="function">
<dt id="numericalFunctions.lib.nf_specialFunctions_C.erf">
<tt class="descclassname">numericalFunctions.lib.nf_specialFunctions_C.</tt><tt class="descname">erf</tt><big>(</big><em>x</em>, <em>complementary = False</em><big>)</big><a class="headerlink" href="#numericalFunctions.lib.nf_specialFunctions_C.erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the error function defined as</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div>-| x</div></blockquote>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div></blockquote>
<p>2    |     2</p>
</div></blockquote>
<dl class="docutils">
<dt>&#8212;&#8211;  |   -t      </dt>
<dd></dd>
<dt>/pi   |           </dt>
<dd><blockquote class="first">
<div><div class="line-block">
<div class="line"><br /></div>
</div>
</div></blockquote>
<p class="last"><a href="#id2"><span class="problematic" id="id3">|</span></a>_  0</p>
</dd>
</dl>
</div></blockquote>
<p>If the second arugment (i.e., complementary) is False (default), the integral is as shown from 0
to x, otherwise, the integral is from x to infinite.</p>
<dl class="docutils">
<dt>Arguments are:  ([o] implies optional argument)</dt>
<dd>x                  a float,
complementary  [o] an integer [default False].</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="numericalFunctions.lib.nf_specialFunctions_C.exponentialIntegral">
<tt class="descclassname">numericalFunctions.lib.nf_specialFunctions_C.</tt><tt class="descname">exponentialIntegral</tt><big>(</big><em>n</em>, <em>x</em><big>)</big><a class="headerlink" href="#numericalFunctions.lib.nf_specialFunctions_C.exponentialIntegral" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the exponential integral defined as</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><ul class="simple">
<li>infinity</li>
</ul>
</div></blockquote>
<div class="line-block">
<div class="line"><br /></div>
<div class="line-block">
<div class="line-block">
<div class="line-block">
<div class="line">-x t     </div>
</div>
<div class="line">e         </div>
</div>
<div class="line">&#8212;&#8212; dt   </div>
<div class="line-block">
<div class="line-block">
<div class="line">n        </div>
</div>
<div class="line">t         </div>
<div class="line"><br /></div>
</div>
</div>
</div>
</div></blockquote>
<p>_  1</p>
</div></blockquote>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>n  an integer that must be greater than or equal to 0
x  a float</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="numericalFunctions.lib.nf_specialFunctions_C.gamma">
<tt class="descclassname">numericalFunctions.lib.nf_specialFunctions_C.</tt><tt class="descname">gamma</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#numericalFunctions.lib.nf_specialFunctions_C.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the gamma function defined as</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div>-| infinity</div></blockquote>
<div class="line-block">
<div class="line"><br /></div>
<div class="line-block">
<div class="line-block">
<div class="line">s-1  -t    </div>
</div>
<div class="line">t    e   dt </div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</div>
</div></blockquote>
<p><a href="#id4"><span class="problematic" id="id5">|</span></a>_  0</p>
</div></blockquote>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>s  a float that must be greater than 0</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="numericalFunctions.lib.nf_specialFunctions_C.incompleteGamma">
<tt class="descclassname">numericalFunctions.lib.nf_specialFunctions_C.</tt><tt class="descname">incompleteGamma</tt><big>(</big><em>s</em>, <em>x</em>, <em>complementary = False</em><big>)</big><a class="headerlink" href="#numericalFunctions.lib.nf_specialFunctions_C.incompleteGamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the incomplete gamma function defined as</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div>-| x</div></blockquote>
<div class="line-block">
<div class="line"><br /></div>
<div class="line-block">
<div class="line-block">
<div class="line">s-1  -t    </div>
</div>
<div class="line">t    e   dt </div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</div>
</div></blockquote>
<p><a href="#id6"><span class="problematic" id="id7">|</span></a>_  0</p>
</div></blockquote>
<p>If the third arugment (i.e., complementary) is False (default), the integral is as shown from 0
to x, otherwise, the integral is from x to infinite.</p>
<dl class="docutils">
<dt>Arguments are:  ([o] implies optional argument)</dt>
<dd>s                  a float that must be greater than 0,
x                  a float that must be greater than 0,
complementary  [o] an integer [default False].</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-numericalFunctions.lib.nf_Legendre_C">
<span id="legendre-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">Legendre</span></tt> Module<a class="headerlink" href="#module-numericalFunctions.lib.nf_Legendre_C" title="Permalink to this headline">¶</a></h2>
<p>A module that contains the class nf_Legendre_C.</p>
<dl class="function">
<dt id="numericalFunctions.lib.nf_Legendre_C.from_pointwiseXY_C">
<tt class="descclassname">numericalFunctions.lib.nf_Legendre_C.</tt><tt class="descname">from_pointwiseXY_C</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.nf_Legendre_C.from_pointwiseXY_C" title="Permalink to this definition">¶</a></dt>
<dd><p>The nf_Legendre_C class limits the maximum Legendre order that an instance can have.
This function returns the largest allowed Legendre order.</p>
<p>Arguments are: (this method does not take any arguments).</p>
</dd></dl>

<dl class="function">
<dt id="numericalFunctions.lib.nf_Legendre_C.maxMaxOrder">
<tt class="descclassname">numericalFunctions.lib.nf_Legendre_C.</tt><tt class="descname">maxMaxOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.nf_Legendre_C.maxMaxOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>The nf_Legendre_C class limits the maximum Legendre order that an instance can have.
This function returns the largest allowed Legendre order.</p>
<p>Arguments are: (this method does not take any arguments).</p>
</dd></dl>

</div>
<div class="section" id="module-numericalFunctions.lib.pointwiseXY_C">
<span id="pointwisexy-c-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">pointwiseXY_C</span></tt> Module<a class="headerlink" href="#module-numericalFunctions.lib.pointwiseXY_C" title="Permalink to this headline">¶</a></h2>
<p>A module that contains the class pointwiseXY_C.</p>
<dl class="function">
<dt id="numericalFunctions.lib.pointwiseXY_C.basicGaussian">
<tt class="descclassname">numericalFunctions.lib.pointwiseXY_C.</tt><tt class="descname">basicGaussian</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.basicGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new pointwiseXY_C instance constructed from the following equation</p>
<blockquote>
<div>exp( ( x^2 / 2 )</div></blockquote>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>accuracy        the accuracy of linear interpolation,</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="numericalFunctions.lib.pointwiseXY_C.createFromFunction">
<tt class="descclassname">numericalFunctions.lib.pointwiseXY_C.</tt><tt class="descname">createFromFunction</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.createFromFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointwiseXY_C instance which represents the function f(x) where f is the second argument and must be a
function reference. The function f must take two arguments. The first arugment to f is x and the second is the third
argument to createFromFunction. The function f must return, as a float, the y-value at x. The returned pointwiseXY_C
instance may contain more points then xs (the first argument) as createFromFunction does infilling. That is, points
are added recursively between the points in xs until accuracy or biSectionMax is reached.</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd><p class="first">xs            An ascending list of x-values to use as an initial guess for the refinement of the returned pointwiseXY_C instance.
f             A function that returns the y-value given an x-value.
parameters    Any python object which may be needed by f. Passed as the second argument to f.
accuracy      The accuracy for infilling.
biSectionMax  The maximum number of bi-sections for infilling.
checkForRoots [o] If true, and biSectionMax &gt; 0, an additional point is added whenever two consecutive points cross the y-axis</p>
<blockquote>
<div>at (or close to) the root (i.e., the y crossing point) (default is False).</div></blockquote>
<p class="last">infill        [o] Infill value used for the returned pointwiseXY_C instance (default is True).
safeDivide    [o] SafeDivide value used for the returned pointwiseXY_C instance (default is True).</p>
</dd>
</dl>
<p>Example: Return a pointwise representation of &#8216;x * sin( x**2 )&#8217; in the domain [1, 10].</p>
<p>import math
import pointwiseXY_C
def f( x, args ) :</p>
<blockquote>
<div>return( x * math.sin( x * x ) )</div></blockquote>
<p>xSin_xx = pointwiseXY_C.createFromFunction( ( 1, 10 ), f, None, 1e-3, 12 )</p>
<p># A better solution may be to input the known zeros of f and force them to be 0., as</p>
<p>xs = [ 1 ] + [ math.sqrt( i * math.pi ) for i in xrange( 1, int( math.sqrt( 100 / math.pi ) ) ) ] + [ 10 ]
xSin_xx = pointwiseXY_C.createFromFunction( xs, f, None, 1e-3, 12, checkForRoots = True )</p>
</dd></dl>

<dl class="function">
<dt id="numericalFunctions.lib.pointwiseXY_C.erf">
<tt class="descclassname">numericalFunctions.lib.pointwiseXY_C.</tt><tt class="descname">erf</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.erf" title="Permalink to this definition">¶</a></dt>
<dd><p>For internal use only. This is a deprecated function, do not use!</p>
</dd></dl>

<dl class="function">
<dt id="numericalFunctions.lib.pointwiseXY_C.gaussian">
<tt class="descclassname">numericalFunctions.lib.pointwiseXY_C.</tt><tt class="descname">gaussian</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new pointwiseXY_C instance constructed from the following equation</p>
<blockquote>
<div>amplitude * exp( ( ( x - offset ) / sigma )^2 / 2 )        for xMin &lt;= x &lt;= xMax</div></blockquote>
<dl class="docutils">
<dt>Arguments are:  ([o] implies optional argument)</dt>
<dd>accuracy        the accuracy of linear interpolation,
xMin            the lower x point generated,
xMax            the upper x point generated,
offset     [o]  the x offset of the center of the Gaussian,
sigma      [o]  width of the Gaussian,
amplitude  [o]  the Gaussian&#8217;s amplitude,
dullEps    [o]  currently not used.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="numericalFunctions.lib.pointwiseXY_C.interpolatePoint">
<tt class="descclassname">numericalFunctions.lib.pointwiseXY_C.</tt><tt class="descname">interpolatePoint</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.interpolatePoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns interpolation of x for x1 &lt;= x &lt;= x2 given x1, y1, x2, y2 and interpolation law.
Arguments are:
interpolation   a string representing the interpolation law (e.g., &#8216;log,linear&#8217;),
x               x point of interpolated y-value,
x1              lower x-value,
y1              y(x1),
x2              upper x-value,
y2              y(x2).</p>
</dd></dl>

<dl class="function">
<dt id="numericalFunctions.lib.pointwiseXY_C.unitbaseInterpolate">
<tt class="descclassname">numericalFunctions.lib.pointwiseXY_C.</tt><tt class="descname">unitbaseInterpolate</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.unitbaseInterpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unitbase interpolation of two XYs objects at w where the axes are labeled (w, x, y).</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>w       the point between lw and uw to return the unitbase interpolation of lXY and uXY,
lw      the w point where lXY resides,
lXY     a pointwiseXY_C instance for a function y(x),
uw      the w point where uXY resides,
uXY     a pointwiseXY_C instance for a function y(x),</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pointwisexy-c-pointwisexy-c-class">
<h2><tt class="xref py py-class docutils literal"><span class="pre">pointwiseXY_C.pointwiseXY_C</span></tt> Class<a class="headerlink" href="#pointwisexy-c-pointwisexy-c-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C">
<em class="property">class </em><tt class="descclassname">numericalFunctions.lib.pointwiseXY_C.</tt><tt class="descname">pointwiseXY_C</tt><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The pointwiseXY_C class stores and manipulates a list of XY points (i.e., [x, y] pairs).
Methods to add, substract, multiply and divide a pointwiseXY_C object with a scaler
(i.e., a number) or other pointwiseXY_C object are provided.</p>
<dl class="docutils">
<dt>Constructor arguments are:</dt>
<dd><p class="first">initialSize     the initial size of the primary data cache (default = 100),
overflowSize    the initial size of the secondary (overflow) data cache (default = 10),
data            the [x_i, y_i] pairs given as described by the dataForm argument,
dataForm        can be one of three strings (case is ignored) that describes the form of data:</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;XYs&#8217;      data are a sequence of [x_i, y_i] pairs with x_i ascending (i.e., x_i &lt; x_{i+1})</dt>
<dd>(e.g., data = [ [ 1, 1 ], [ 2.3, 2 ], [ 3.4, 6 ], [ 5.1, 4.3 ] ])</dd>
<dt>&#8216;XsAndYs&#8217;  data are given as [xs, ys] where xs the list of x-values and ys the matching list of y-values,</dt>
<dd>(e.g., data = [ [ 1, 2.3, 3.4, 5.1 ], [ 1, 2, 6, 4.3 ] ]),</dd>
<dt>&#8216;list&#8217;     data are given as [x_0, y_0, x_1, y_1, ..., x_n, y_n],</dt>
<dd>(e.g., data = [ 1, 1, 2.3, 2, 3.4, 6, 5.1, 4.3 ]),</dd>
</dl>
</div></blockquote>
<p>accuracy        the accuracy of the data for the given interpolation (default = 1e-3)
biSectionMax    at times (e.g., multiplication), points may need to be added to maintain the give accuracy. In this case, a region</p>
<blockquote>
<div>is continuously divided into two until the accuracy is met or biSectionMax divisions have occurred (default = 3),</div></blockquote>
<dl class="docutils">
<dt>interpolation   can be one of the following strings:</dt>
<dd>&#8216;flat&#8217;              for the domain [x_i,x_{i+1}), the y-value is y_i
&#8216;linear,flat&#8217;       same as &#8216;flat&#8217;
&#8216;log,flat&#8217;          same as &#8216;flat&#8217;
&#8216;linear,linear&#8217;
&#8216;linear,log&#8217;
&#8216;log,linear&#8217;
&#8216;log,log&#8217;
&#8216;other&#8217;             The rest are equivalent to this sting.
&#8216;other,*&#8217;           the y interpolation can be any string.
&#8216;linear,other&#8217;
&#8216;log,other&#8217;</dd>
</dl>
<p class="last">infill          if True, multiplication will continuously divide a region until accuracy or biSectionMax is met (default = True),
safeDivide      if True, safe division is used (default = False)</p>
</dd>
</dl>
<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.allocatedSize">
<tt class="descname">allocatedSize</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.allocatedSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of memory allocated in the points region.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.applyFunction">
<tt class="descname">applyFunction</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.applyFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance which is y(x) = f(y_s(x)) where f is a function of one variable and y_s(x) is self&#8217;s.
y-value at x. The function f must take two arguments. The first is y_s(x) and the second (not including self)
is the second argument to applyFunction. The returned object may contain more points then self as applyFunction
does infilling. That is, points are added recursively between points until accuracy or biSectionMax is reached.</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd><p class="first">f             a function that returns the new y(x) given the old y(x),
parameters    any python object. Passed as the second argument to f,
accuracy      [o] The accuracy for infilling. If not present, taken from self,
biSectionMax  [o] The maximum number of bi-sections for infilling. If not present, taken from self.
checkForRoots [o] If true, and biSectionMax &gt; 0, an addition point is added whenever two consecutive points cross the y-axis</p>
<blockquote class="last">
<div>at (or close to) the root (i.e., the y crossing point).</div></blockquote>
</dd>
</dl>
<p>To return f(x), set self&#8217;s y-values to x (i.e., y(x) = x for self).</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.areDomainsMutual">
<tt class="descname">areDomainsMutual</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.areDomainsMutual" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine returns True if self and the first argument have a mutual domain, and false otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.changeInterpolation">
<tt class="descname">changeInterpolation</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.changeInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance that is equivalent to self, but with the interpolation changed to interpolation.</p>
<dl class="docutils">
<dt>Arguments are: ([o] implies optional argument)</dt>
<dd>interpolation  [o] the new interpolation (default is &#8216;linear,linear&#8217;),
accuracy       [o] the accuracy of the conversion from the old to the new interpolation (default is self&#8217;s accuracy),
lowerEps       [o] for flat to linear, the lower eps,
upperEps       [o] the flat to linear, the upper eps. lowerEps and upperEps cannot both be 0.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.changeInterpolationIfNeeded">
<tt class="descname">changeInterpolationIfNeeded</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.changeInterpolationIfNeeded" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self if it is one of the allowed interpolations. Otherwise, a new instance is returned that is equivalent to self,
but with the interpolation changed to the interpolation of the first allowed interpolations.</p>
<dl class="docutils">
<dt>Arguments are: ([o] implies optional argument)</dt>
<dd>allowedInterpolations the list of allowed interpolations,
accuracy              [o] the accuracy of the conversion from the old to the new interpolation (default is self&#8217;s accuracy),
lowerEps              [o] for flat to linear, the lower eps,
upperEps              [o] the flat to linear, the upper eps. lowerEps and upperEps cannot both be 0.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.clip">
<tt class="descname">clip</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance which is the same as self, but with the y-values clipped between yMin and yMax
clip may add points, to insure that the return instance has the same shape as self between yMin and yMax</p>
<dl class="docutils">
<dt>Arguments are: ([o] implies optional argument)</dt>
<dd>yMin  [o]   the lower y-value for clipping,
yMax  [o]   the upper y-value for clipping.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.coalescePoints">
<tt class="descname">coalescePoints</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.coalescePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves all points in overflow region to points region.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.convolute">
<tt class="descname">convolute</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.convolute" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance which is the convolution of self with the first argument, that must also be a pointwiseXY_C instance.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of self.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copyDataToXYs">
<tt class="descname">copyDataToXYs</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copyDataToXYs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list of self&#8217;s data as [ x1, y1 ], ... [ xn, yn ] ].</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>xScale [o]  a float to scale all x-values by,
yScale [o]  a float to scale all y-values by.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copyDataToXsAndYs">
<tt class="descname">copyDataToXsAndYs</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copyDataToXsAndYs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns python list of length two. The first element is a python list of
self&#8217;s x-values and the second element is a python list of self&#8217;s y-values.</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>xScale [o]  a float to scale all x-values by,
yScale [o]  a float to scale all y-values by.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.dullEdges">
<tt class="descname">dullEdges</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.dullEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance that is a copy of self, except the endpoints are guaranteed to have 0&#8217;s for y-values
as long as lowerEps and/or upperEps are none zero (see below). The following algorithm is used.</p>
<p>If lowerEps is zero or the y-value at xMin is 0, then nothing is added at the lower end. Otherwise, the following is
done at the lower end.</p>
<blockquote>
<div><dl class="docutils">
<dt>If lowerEps is positive, a point &#8216;abs( xMin * lowerEps )&#8217; above xMin is added with its interpolated y-value; provided,</dt>
<dd>this x value is &#8216;abs( xMin * lowerEps )&#8217; less than the next x-value. In the prior sentence, if xMin is 0, then
replace &#8216;abs( xMin * lowerEps )&#8217; with &#8216;abs( lowerEps )&#8217;. Independent of whether a point is added, xMin&#8217;s y-value is
set to 0.</dd>
<dt>If lowerEps is negative, the logic for adding the point above xMin for positive lowerEps is followed. In addition, a</dt>
<dd>point is added &#8216;abs( xMin * lowerEps )&#8217; below xMin with a value of zero and the point at xMin is reset by
interpolating the new surrounding values. However, if positiveXOnly is True and the point below xMin would cause
a negative x-value (and xMin is not negative) then the logic for positive lowerEps is implemented instead.</dd>
<dt>The logic for upperEps is similar to lowerEps except, replace xMin with xMax, below with above and above with below.</dt>
<dd>Also positiveXOnly is ignored.</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>lowerEps       [o] a point (or two if lowerEps is negative) is (are) added a distance xMin * lowerEps from xMin,
upperEps       [o] a point (or two if upperEps is negative) is (are) added a distance xMax * upperEps from xMax,
positiveXOnly  [o] this only applies to lowerEps and only if an added point would be negative when xMin is non-negative.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.exp">
<tt class="descname">exp</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with ts y-values set to exp( a * [self&#8217;s y-values] ). x-values are added to meet required accuaracy.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getAccuracy">
<tt class="descname">getAccuracy</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getAccuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self&#8217;s accuracy value.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getBiSectionMax">
<tt class="descname">getBiSectionMax</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getBiSectionMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self&#8217;s biSectionMax value.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getDomainGrid">
<tt class="descname">getDomainGrid</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getDomainGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of x-values for self.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getInfill">
<tt class="descname">getInfill</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getInfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self&#8217;s infill flag.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getInterpolation">
<tt class="descname">getInterpolation</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self&#8217;s interpolation as a string.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getSafeDivide">
<tt class="descname">getSafeDivide</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getSafeDivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self&#8217;s safeDivide flag.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getSecondaryCacheSize">
<tt class="descname">getSecondaryCacheSize</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getSecondaryCacheSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of self&#8217;s secondary cache.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getValue">
<tt class="descname">getValue</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the y value at x.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupOneFunction">
<tt class="descname">groupOneFunction</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupOneFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list of float values. Each value is the integral of self between two consecutive group boundaries.</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd><p class="first">groupBoundaries     the list of group boundaries,
norm                each value returned can be normalized as directed by one of the following allowed values</p>
<blockquote class="last">
<div>None                no normalization is applied,
&#8216;dx&#8217;                each value is normalized by the width of its interval,
list                a list of floats, one each for each group which the group is normalized by.</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupThreeFunctions">
<tt class="descname">groupThreeFunctions</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupThreeFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list of float values. Each value is the integral of the product of self, f2 and f3 between two consecutive group boundaries.</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd><p class="first">f2                  the second pointwiseXY_C function with the integrand being the product of self * f2 * f3
f3                  the third pointwiseXY_C function with the integrand being the product of self * f2 * f3
groupBoundaries     the list of group boundaries,
norm                each value returned can be normalized as directed by one of the following allowed values</p>
<blockquote class="last">
<div>None                no normalization is applied,
&#8216;dx&#8217;                each value is normalized by the width of its interval,
list                a list of floats, one each for each group which the group is normalized by.</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupTwoFunctions">
<tt class="descname">groupTwoFunctions</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupTwoFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list of float values. Each value is the integral of the product of self and f2 between two consecutive group boundaries.</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd><p class="first">f2                  the second pointwiseXY_C function with the integrand being the product of self * f2
groupBoundaries     the list of group boundaries,
norm                each value returned can be normalized as directed by one of the following allowed values</p>
<blockquote class="last">
<div>None                no normalization is applied,
&#8216;dx&#8217;                each value is normalized by the width of its interval,
list                a list of floats, one each for each group which the group is normalized by.</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrate">
<tt class="descname">integrate</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns float a value that is the integral of self from xMin to xMax.</p>
<dl class="docutils">
<dt>Arguments are: ([o] implies optional argument)</dt>
<dd>xMin    [o] the lower limit of the integral, default is xMin of self,
xMax    [o] the upper limit of the integral, default is xMax of self.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithWeight_sqrt_x">
<tt class="descname">integrateWithWeight_sqrt_x</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithWeight_sqrt_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns float a value that is the integral of self weighted by sqrt( x ) from xMin to xMax (i.e. integral dx sqrt( x ) * self(x)).</p>
<dl class="docutils">
<dt>Arguments are: ([o] implies optional argument)</dt>
<dd>xMin    [o] the lower limit of the integral, default is xMin of self,
xMax    [o] the upper limit of the integral, default is xMax of self.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithWeight_x">
<tt class="descname">integrateWithWeight_x</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithWeight_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns float a value that is the integral of self weighted by x from xMin to xMax (i.e. integral dx x * self(x)).</p>
<dl class="docutils">
<dt>Arguments are: ([o] implies optional argument)</dt>
<dd>xMin    [o] the lower limit of the integral, default is xMin of self,
xMax    [o] the upper limit of the integral, default is xMax of self.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.mergeClosePoints">
<tt class="descname">mergeClosePoints</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.mergeClosePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new pointwiseXY_C object whose x values are the union of self and other.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.mutualify">
<tt class="descname">mutualify</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.mutualify" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list containing two pointwiseXY_C instances that are the mutualification of self and other.
Mutualification is the act of modifying, if needed, two pointwiseXY_C instances so that their domains are mutual.
Self and other are not altered.</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>lowerEps1       the lowerEps applied to self if needed, see dullEdges for meaning,
upperEps1       the upperEps applied to self if needed, see dullEdges for meaning,
positiveXOnly1  the positiveXOnly applied to self if needed, see dullEdges for meaning,
other           the second pointwiseXY_C instance to mutualify self with,
lowerEps2       the lowerEps applied to other if needed, see dullEdges for meaning,
upperEps2       the upperEps applied to other if needed, see dullEdges for meaning,
positiveXOnly2  the positiveXOnly applied to other if needed, see dullEdges for meaning,</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.normalize">
<tt class="descname">normalize</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with the same x-values as self but with the y-values scaled so that the area of the curve is 1.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.overflowAllocatedSize">
<tt class="descname">overflowAllocatedSize</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.overflowAllocatedSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of memory allocated for the overflow region.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.overflowLength">
<tt class="descname">overflowLength</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.overflowLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns of number of points in the overflow region.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.plot">
<tt class="descname">plot</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls Gnuplot, if it exists, to plot self. This is a simple method, mainly for debugging.</p>
<p>Arguments: None.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.reallocateOverflowPoints">
<tt class="descname">reallocateOverflowPoints</tt><big>(</big><em>size</em><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.reallocateOverflowPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusts the memory allocated for the overflow points to size (the first and only argument).</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.reallocatePoints">
<tt class="descname">reallocatePoints</tt><big>(</big><em>size</em>, <em>forceSmaller = True</em><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.reallocatePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusts the memory allocated for primary points to the maximum of size and the current length of self.</p>
<dl class="docutils">
<dt>Arguments are: ([o] implies optional argument)</dt>
<dd>size              the desired allocated size of self (actual size will be larger if length is greater than size),
forceSmaller  [o] if False action is only taken if allocated is significantly greater than size (default is True).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setAccuracy">
<tt class="descname">setAccuracy</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setAccuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets self&#8217;s accuracy value and returns the actual value set.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setBiSectionMax">
<tt class="descname">setBiSectionMax</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setBiSectionMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets self&#8217;s biSectionMax value and returns the actual value set.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setData">
<tt class="descname">setData</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setData" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the data in self with the frist argument. This argument must be a list. Each item of the list must contain two floats, or objects that can be convert to float (e.g., [ [ 1, 2 ], [ 2, 4 ], [ 4, 0.5 ] ]</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setDataFromList">
<tt class="descname">setDataFromList</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setDataFromList" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the data in self with the python list given by the first argument.</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>xys      the list of xy-values as a single python list (e.g., [ 1, 2, 4, 3, 5, 6]</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setDataFromXsAndYs">
<tt class="descname">setDataFromXsAndYs</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setDataFromXsAndYs" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the data in self with the 2 python lists given by the first 2 arguments.</p>
<dl class="docutils">
<dt>Arguments are:</dt>
<dd>xs      the list of x-values
ys      the list of y-values</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setInfill">
<tt class="descname">setInfill</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setInfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets self&#8217;s infill flag to the first argument.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setSafeDivide">
<tt class="descname">setSafeDivide</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setSafeDivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets self&#8217;s safeDivide flag to the first argument.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setSecondaryCacheSize">
<tt class="descname">setSecondaryCacheSize</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setSecondaryCacheSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the size of self&#8217;s secondary cache to size.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setValue">
<tt class="descname">setValue</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the y value at x.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.showInteralStructure">
<tt class="descname">showInteralStructure</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.showInteralStructure" title="Permalink to this definition">¶</a></dt>
<dd><p>For debbuging only. Dumps information on internal data.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thicken">
<tt class="descname">thicken</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thicken" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with denser points than self filled in using self&#8217;s interpolation. The number of points added are determined by the following arguments
sectionSubdivideMax    maximum number of points to insert between consecutive points,
dxMax                  minimum dx step,
fxMax                  minimum fractional step.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thin">
<tt class="descname">thin</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with points of self thinned to accuracy of argument one.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.toString">
<tt class="descname">toString</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.toString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representation of self. This method has three keyword parameters:
pairsPerLine, format and pairSeparator which are defined as,
pairsPerLine    the number of pairs to put on each line
format          a valid format to convert an (x,y) pair (i.e., two floats) into a string (e.g. format = &#8216; %.3f %12.5e&#8217;)
pairSeparator   a string to put between every pair (e.g, to put a comma to separate pairs use pairSeparator = &#8216;,&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.trim">
<tt class="descname">trim</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.trim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with excessive 0. y-value points at beginning and end of self removed.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.union">
<tt class="descname">union</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new pointwiseXY_C object whose x values are the union of self and other.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.xMax">
<tt class="descname">xMax</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.xMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last point&#8217;s x value.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.xMin">
<tt class="descname">xMin</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.xMin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first point&#8217;s x value.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.xSlice">
<tt class="descname">xSlice</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.xSlice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with self sliced between xMin and xMax.</p>
<dl class="docutils">
<dt>Arguments are: ([o] implies optional argument)</dt>
<dd><p class="first">xMin    [o] the lower x-value of the slice, default is xMin of self,
xMax    [o] the upper x-value of the slice, default is xMax of self,
fill    [o] if True, points are added at xMin and xMax if they are not in self,</p>
<blockquote>
<div>else only existing points in the range [xMin, xMax] are included.</div></blockquote>
<p class="last">dullEps [o] (Currently not implemented) the lower and upper points are dulled, default is 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.yMax">
<tt class="descname">yMax</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.yMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum y-value in self or 0 if self is empty.</p>
</dd></dl>

<dl class="method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.yMin">
<tt class="descname">yMin</tt><big>(</big><big>)</big><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.yMin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimum y-value in self or 0 if self is empty.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/gnd.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">numericalFunctions Package</a><ul>
<li><a class="reference internal" href="#module-numericalFunctions.lib.nf_specialFunctions_C"><tt class="docutils literal"><span class="pre">specialFunctions</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-numericalFunctions.lib.nf_Legendre_C"><tt class="docutils literal"><span class="pre">Legendre</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-numericalFunctions.lib.pointwiseXY_C"><tt class="docutils literal"><span class="pre">pointwiseXY_C</span></tt> Module</a></li>
<li><a class="reference internal" href="#pointwisexy-c-pointwisexy-c-class"><tt class="docutils literal"><span class="pre">pointwiseXY_C.pointwiseXY_C</span></tt> Class</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pqu.test.html"
                        title="previous chapter">test Package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="crossSectionAdjustForHeatedTarget.html"
                        title="next chapter">crossSectionAdjustForHeatedTarget Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/fudge/numericalFunctions.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="crossSectionAdjustForHeatedTarget.html" title="crossSectionAdjustForHeatedTarget Package"
             >next</a> |</li>
        <li class="right" >
          <a href="pqu.test.html" title="test Package"
             >previous</a> |</li>
        <li><a href="../index.html">Fudge and GND 1.2 beta documentation</a> &raquo;</li>
          <li><a href="index.html" >fudge Package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, B.Beck, D. Brown, C. Mattoon, N. Patel, N. Summers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>