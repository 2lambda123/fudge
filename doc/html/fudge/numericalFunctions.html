
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>numericalFunctions Package &#8212; Fudge and GNDS 4.2.3 beta documentation</title>
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="External Packages used in Fudge" href="../externals.html" />
    <link rel="prev" title="fudge.vis.matplotlib package" href="fudge.vis.matplotlib.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../externals.html" title="External Packages used in Fudge"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fudge.vis.matplotlib.html" title="fudge.vis.matplotlib package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fudge and GNDS 4.2.3 beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">fudge Package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">numericalFunctions Package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="numericalfunctions-package">
<h1>numericalFunctions Package<a class="headerlink" href="#numericalfunctions-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="specialfunctions-module">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">specialFunctions</span></code> Module<a class="headerlink" href="#specialfunctions-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="legendre-module">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">Legendre</span></code> Module<a class="headerlink" href="#legendre-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-numericalFunctions.lib.pointwiseXY_C">
<span id="pointwisexy-c-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">pointwiseXY_C</span></code> Module<a class="headerlink" href="#module-numericalFunctions.lib.pointwiseXY_C" title="Permalink to this headline">¶</a></h2>
<p>A module that contains the class pointwiseXY_C.</p>
<dl class="py function">
<dt id="numericalFunctions.lib.pointwiseXY_C.basicGaussian">
<code class="sig-prename descclassname">numericalFunctions.lib.pointwiseXY_C.</code><code class="sig-name descname">basicGaussian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">accuracy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.basicGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new pointwiseXY_C instance constructed from the following equation</p>
<blockquote>
<div><p>exp( ( x^2 / 2 )</p>
</div></blockquote>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>accuracy        the accuracy of linear interpolation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numericalFunctions.lib.pointwiseXY_C.createFromFunction">
<code class="sig-prename descclassname">numericalFunctions.lib.pointwiseXY_C.</code><code class="sig-name descname">createFromFunction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xs</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">parameters</span></em>, <em class="sig-param"><span class="n">accuracy</span></em>, <em class="sig-param"><span class="n">biSectionMax</span></em>, <em class="sig-param"><span class="n">checkForRoots</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">infill</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">saveDivide</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.createFromFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointwiseXY_C instance which represents the function f(x) where f is the second argument and must be a
function reference. The function f must take two arguments. The first arugment to f is x and the second is the third
argument to createFromFunction. The function f must return, as a float, the y-value at x. The returned pointwiseXY_C
instance may contain more points then xs (the first argument) as createFromFunction does infilling. That is, points
are added recursively between the points in xs until accuracy or biSectionMax is reached.</p>
<dl>
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>xs            An ascending list of x-values to use as an initial guess for the refinement of the returned pointwiseXY_C instance.
f             A function that returns the y-value given an x-value.
parameters    Any python object which may be needed by f. Passed as the second argument to f.
accuracy      The accuracy for infilling.
biSectionMax  The maximum number of bi-sections for infilling.
checkForRoots [o] If true, and biSectionMax &gt; 0, an additional point is added whenever two consecutive points cross the y-axis</p>
<blockquote>
<div><p>at (or close to) the root (i.e., the y crossing point) (default is False).</p>
</div></blockquote>
<p>infill        [o] Infill value used for the returned pointwiseXY_C instance (default is True).
safeDivide    [o] SafeDivide value used for the returned pointwiseXY_C instance (default is True).</p>
</dd>
</dl>
<p>Example: Return a pointwise representation of ‘x * sin( x**2 )’ in the domain [1, 10].</p>
<p>import math
import pointwiseXY_C
def f( x, args ) :</p>
<blockquote>
<div><p>return( x * math.sin( x * x ) )</p>
</div></blockquote>
<p>xSin_xx = pointwiseXY_C.createFromFunction( ( 1, 10 ), f, None, 1e-3, 12 )</p>
<p># A better solution may be to input the known zeros of f and force them to be 0., as</p>
<p>xs = [ 1 ] + [ math.sqrt( i * math.pi ) for i in xrange( 1, int( math.sqrt( 100 / math.pi ) ) ) ] + [ 10 ]
xSin_xx = pointwiseXY_C.createFromFunction( xs, f, None, 1e-3, 12, checkForRoots = True )</p>
</dd></dl>

<dl class="py function">
<dt id="numericalFunctions.lib.pointwiseXY_C.createFromString">
<code class="sig-prename descclassname">numericalFunctions.lib.pointwiseXY_C.</code><code class="sig-name descname">createFromString</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">str</span></em>, <em class="sig-param"><span class="n">accuracy</span></em>, <em class="sig-param"><span class="n">biSectionMax</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">'lin-lin'</span></em>, <em class="sig-param"><span class="n">infill</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">safeDivide</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.createFromString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of two elements. The first element is a pointwiseXY_C instance representing the float values
translated from ‘str’. The second element is the portion of ‘str’ not translated</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>str           The containing a list of floats to be converted.
accuracy      The accuracy for infilling.
biSectionMax  The maximum number of bi-sections for infilling.
interpolation [o] the interpolation string (default is ‘lin-lin’).
infill        [o] Infill value used for the returned pointwiseXY_C instance (default is True).
safeDivide    [o] SafeDivide value used for the returned pointwiseXY_C instance (default is True).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numericalFunctions.lib.pointwiseXY_C.defaultAccuracy">
<code class="sig-prename descclassname">numericalFunctions.lib.pointwiseXY_C.</code><code class="sig-name descname">defaultAccuracy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.defaultAccuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the default accuracy for the __init_ method.</p>
</dd></dl>

<dl class="py function">
<dt id="numericalFunctions.lib.pointwiseXY_C.floatToShortestString">
<code class="sig-prename descclassname">numericalFunctions.lib.pointwiseXY_C.</code><code class="sig-name descname">floatToShortestString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.floatToShortestString" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>floatToShortestString( value, significantDigits = 15, trimZeros = True, keepPeriod = False,</dt><dd><p>favorEFormBy = 0, includeSign = False )</p>
</dd>
</dl>
<p>Returns the float converted to either the E-form (i.e., ‘%e’) and F-form (i.e., ‘%f’) with significantDigits.
The form with the shortest string representation of the float value is returned.</p>
<dl>
<dt>Arguments are:</dt><dd><p>value               the float value to convert to a string,
significantDigits   The number of significant digits desired. Restricted to the range 0 to 24 inclusive,
trimZeros           If True, unneeded zeros to the right of ‘.’ are removed,
keepPeriod          If False, ‘.’ is removed if there is no digit to its right,
favorEFormBy        The integer subtracted from the length of the E-form before the form</p>
<blockquote>
<div><p>with the shortest representation is determined,</p>
</div></blockquote>
<dl class="simple">
<dt>includeSign         If True, the returned string will always start with a sign character</dt><dd><p>(i.e., ‘+’ or ‘-‘). Otherwise, only negative values will have a sign.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numericalFunctions.lib.pointwiseXY_C.gaussian">
<code class="sig-prename descclassname">numericalFunctions.lib.pointwiseXY_C.</code><code class="sig-name descname">gaussian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">accuracy</span></em>, <em class="sig-param"><span class="n">domainMin</span></em>, <em class="sig-param"><span class="n">domainMax</span></em>, <em class="sig-param"><span class="n">offset</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">sigma</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">dullEps</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new pointwiseXY_C instance constructed from the following equation</p>
<blockquote>
<div><p>amplitude * exp( ( ( x - offset ) / sigma )^2 / 2 )        for domainMin &lt;= x &lt;= domainMax</p>
</div></blockquote>
<dl class="simple">
<dt>Arguments are:  ([o] implies optional argument)</dt><dd><p>accuracy        the accuracy of linear interpolation,
domainMin            the lower x point generated,
domainMax            the upper x point generated,
offset     [o]  the x offset of the center of the Gaussian,
sigma      [o]  width of the Gaussian,
amplitude  [o]  the Gaussian’s amplitude,
dullEps    [o]  currently not used.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="numericalFunctions.lib.pointwiseXY_C.interpolatePoint">
<code class="sig-prename descclassname">numericalFunctions.lib.pointwiseXY_C.</code><code class="sig-name descname">interpolatePoint</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">interpolation</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">y1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">y2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.interpolatePoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns interpolation of x for x1 &lt;= x &lt;= x2 given x1, y1, x2, y2 and interpolation law.
Arguments are:</p>
<blockquote>
<div><p>interpolation   a string representing the interpolation law (e.g., ‘log-lin’; see constructor’s docstring),
x               x point of interpolated y-value,
x1              lower x-value,
y1              y(x1),
x2              upper x-value,
y2              y(x2).</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="numericalFunctions.lib.pointwiseXY_C.unitbaseInterpolate">
<code class="sig-prename descclassname">numericalFunctions.lib.pointwiseXY_C.</code><code class="sig-name descname">unitbaseInterpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">lw</span></em>, <em class="sig-param"><span class="n">lXY</span></em>, <em class="sig-param"><span class="n">uw</span></em>, <em class="sig-param"><span class="n">uXY</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.unitbaseInterpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unitbase interpolation of two XYs objects at w where the axes are labeled (w, x, y).</p>
<dl>
<dt>Arguments are:</dt><dd><blockquote>
<div><p>w           the point between lw and uw to return the unitbase interpolation of lXY and uXY,
lw          the w point where lXY resides,
lXY         a pointwiseXY_C instance for a function y(x),
uw          the w point where uXY resides,
uXY         a pointwiseXY_C instance for a function y(x),</p>
</div></blockquote>
<p>scaleRange    if True range values are scaled, otherwise they are unchanged.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pointwisexy-c-pointwisexy-c-class">
<h2><code class="xref py py-class docutils literal notranslate"><span class="pre">pointwiseXY_C.pointwiseXY_C</span></code> Class<a class="headerlink" href="#pointwisexy-c-pointwisexy-c-class" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C">
<em class="property">class </em><code class="sig-prename descclassname">numericalFunctions.lib.pointwiseXY_C.</code><code class="sig-name descname">pointwiseXY_C</code><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The pointwiseXY_C class stores and manipulates a list of XY points (i.e., [x, y] pairs).
Methods to add, substract, multiply and divide a pointwiseXY_C object with a scaler
(i.e., a number) or other pointwiseXY_C object are provided.</p>
<p>Constructor:
pointwiseXY_C( data = [], dataForm = ‘xys’, initialSize = 100, overflowSize = 10, accuracy = defaultAccuracy( ), biSectionMax = 3., interpolation = ‘lin-lin’, infill = True, safeDivide = False, userFlag = 0 )</p>
<dl>
<dt>Constructor arguments are ([o] implies optional argument):</dt><dd><p>data            [o] the [x_i, y_i] pairs given as described by the dataForm argument,
dataForm        [o] can be one of three strings (case is ignored) that describes the form of data:</p>
<blockquote>
<div><dl class="simple">
<dt>‘XYs’      data are a sequence of [x_i, y_i] pairs with x_i ascending (i.e., x_i &lt; x_{i+1})</dt><dd><p>(e.g., data = [ [ 1, 1 ], [ 2.3, 2 ], [ 3.4, 6 ], [ 5.1, 4.3 ] ])</p>
</dd>
<dt>‘XsAndYs’  data are given as [xs, ys] where xs the list of x-values and ys the matching list of y-values,</dt><dd><p>(e.g., data = [ [ 1, 2.3, 3.4, 5.1 ], [ 1, 2, 6, 4.3 ] ]),</p>
</dd>
<dt>‘list’     data are given as [x_0, y_0, x_1, y_1, …, x_n, y_n],</dt><dd><p>(e.g., data = [ 1, 1, 2.3, 2, 3.4, 6, 5.1, 4.3 ]),</p>
</dd>
</dl>
</div></blockquote>
<p>initialSize     [o] the initial size of the primary data cache (default = 100),
overflowSize    [o] the initial size of the secondary (overflow) data cache (default = 10),
accuracy        [o] the accuracy of the data for the given interpolation (default is value returned by function defaultAccuracy)
biSectionMax    [o] at times (e.g., multiplication), points may need to be added to maintain the give accuracy. In this case, a region</p>
<blockquote>
<div><p>is continuously divided into two until the accuracy is met or biSectionMax divisions have occurred (default = 3),</p>
</div></blockquote>
<dl class="simple">
<dt>interpolation   [o] can be one of the following strings:</dt><dd><p>‘flat’              for the domain [x_i,x_{i+1}), the y-value is y_i
‘lin-lin’
‘lin-log’
‘log-lin’
‘log-log’
‘other’</p>
</dd>
</dl>
<p>infill          [o] if True, multiplication will continuously divide a region until accuracy or biSectionMax is met (default = True),
safeDivide      [o] if True, safe division is used (default = False)
userFlag        [o] an integer (of type C int) used to store a user defined flag. (see getUserFlag and setUserFlag).</p>
</dd>
</dl>
<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.allocatedSize">
<code class="sig-name descname">allocatedSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.allocatedSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of memory allocated in the points region.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.applyFunction">
<code class="sig-name descname">applyFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.applyFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance which is y(x) = f(y_s(x)) where f is a function of one variable and y_s(x) is self’s.
y-value at x. The function f must take two arguments. The first is y_s(x) and the second (not including self)
is the second argument to applyFunction. The returned object may contain more points then self as applyFunction
does infilling. That is, points are added recursively between points until accuracy or biSectionMax is reached.</p>
<dl>
<dt>Arguments are:</dt><dd><p>f             a function that returns the new y(x) given the old y(x),
parameters    any python object. Passed as the second argument to f,
accuracy      [o] The accuracy for infilling. If not present, taken from self,
biSectionMax  [o] The maximum number of bi-sections for infilling. If not present, taken from self.
checkForRoots [o] If true, and biSectionMax &gt; 0, an addition point is added whenever two consecutive points cross the y-axis</p>
<blockquote>
<div><p>at (or close to) the root (i.e., the y crossing point).</p>
</div></blockquote>
</dd>
</dl>
<p>To return f(x), set self’s y-values to x (i.e., y(x) = x for self).</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.areDomainsMutual">
<code class="sig-name descname">areDomainsMutual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.areDomainsMutual" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine returns True if self and the first argument have a mutual domain, and false otherwise.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.changeInterpolation">
<code class="sig-name descname">changeInterpolation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.changeInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance that is equivalent to self, but with the interpolation changed to interpolation.</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>interpolation  [o] the new interpolation (default is ‘lin-lin’),
accuracy       [o] the accuracy of the conversion from the old to the new interpolation (default is self’s accuracy),
lowerEps       [o] for flat to linear, the lower eps,
upperEps       [o] the flat to linear, the upper eps. lowerEps and upperEps cannot both be 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.changeInterpolationIfNeeded">
<code class="sig-name descname">changeInterpolationIfNeeded</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.changeInterpolationIfNeeded" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self if it is one of the allowed interpolations. Otherwise, a new instance is returned that is equivalent to self,
but with the interpolation changed to the interpolation of the first allowed interpolations.</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>allowedInterpolations the list of allowed interpolations,
accuracy              [o] the accuracy of the conversion from the old to the new interpolation (default is self’s accuracy),
lowerEps              [o] for flat to linear, the lower eps,
upperEps              [o] the flat to linear, the upper eps. lowerEps and upperEps cannot both be 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.clip">
<code class="sig-name descname">clip</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance which is the same as self, but with the y-values clipped between rangeMin and rangeMax
clip may add points, to insure that the return instance has the same shape as self between rangeMin and rangeMax</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>rangeMin  [o]   the lower y-value for clipping,
rangeMax  [o]   the upper y-value for clipping.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.cloneToInterpolation">
<code class="sig-name descname">cloneToInterpolation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.cloneToInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>A clone of self is returned with its interpolation changed, but no points altered or added.
Arguments are:</p>
<blockquote>
<div><p>interpolation   the interpolation for the cloned instance.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.coalescePoints">
<code class="sig-name descname">coalescePoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.coalescePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves all points in overflow region to points region.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.convolute">
<code class="sig-name descname">convolute</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.convolute" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance which is the convolution of self with the first argument, that must also be a pointwiseXY_C instance.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of self.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copyDataToXYs">
<code class="sig-name descname">copyDataToXYs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copyDataToXYs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list of self’s data as [ x1, y1 ], … [ xn, yn ] ].</p>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>xScale [o]  a float to scale all x-values by,
yScale [o]  a float to scale all y-values by.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copyDataToXsAndYs">
<code class="sig-name descname">copyDataToXsAndYs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.copyDataToXsAndYs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns python list of length two. The first element is a python list of
self’s x-values and the second element is a python list of self’s y-values.</p>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>xScale [o]  a float to scale all x-values by,
yScale [o]  a float to scale all y-values by.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domain">
<code class="sig-name descname">domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the x-value of the first and last points as a tuple.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domainGrid">
<code class="sig-name descname">domainGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domainGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of x-values for self.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domainMax">
<code class="sig-name descname">domainMax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domainMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the x-value of the last point.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domainMin">
<code class="sig-name descname">domainMin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domainMin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the x-value of the first point.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domainSlice">
<code class="sig-name descname">domainSlice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.domainSlice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with self sliced between domainMin and domainMax.</p>
<dl>
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>domainMin    [o] the lower x-value of the slice, default is domainMin of self,
domainMax    [o] the upper x-value of the slice, default is domainMax of self,
fill    [o] if True, points are added at domainMin and domainMax if they are not in self,</p>
<blockquote>
<div><p>else only existing points in the range [domainMin, domainMax] are included.</p>
</div></blockquote>
<p>dullEps [o] (Currently not implemented) the lower and upper points are dulled, default is 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.dullEdges">
<code class="sig-name descname">dullEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.dullEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance that is a copy of self, except the endpoints are guaranteed to have 0’s for y-values
as long as lowerEps and/or upperEps are none zero (see below). The following algorithm is used.</p>
<p>If lowerEps is zero or the y-value at domainMin is 0, then nothing is added at the lower end. Otherwise, the following is
done at the lower end.</p>
<blockquote>
<div><dl class="simple">
<dt>If lowerEps is positive, a point ‘abs( domainMin * lowerEps )’ above domainMin is added with its interpolated y-value; provided,</dt><dd><p>this x value is ‘abs( domainMin * lowerEps )’ less than the next x-value. In the prior sentence, if domainMin is 0, then
replace ‘abs( domainMin * lowerEps )’ with ‘abs( lowerEps )’. Independent of whether a point is added, domainMin’s y-value is
set to 0.</p>
</dd>
<dt>If lowerEps is negative, the logic for adding the point above domainMin for positive lowerEps is followed. In addition, a</dt><dd><p>point is added ‘abs( domainMin * lowerEps )’ below domainMin with a value of zero and the point at domainMin is reset by
interpolating the new surrounding values. However, if positiveXOnly is True and the point below domainMin would cause
a negative x-value (and domainMin is not negative) then the logic for positive lowerEps is implemented instead.</p>
</dd>
<dt>The logic for upperEps is similar to lowerEps except, replace domainMin with domainMax, below with above and above with below.</dt><dd><p>Also positiveXOnly is ignored.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>lowerEps       [o] a point (or two if lowerEps is negative) is (are) added a distance domainMin * lowerEps from domainMin,
upperEps       [o] a point (or two if upperEps is negative) is (are) added a distance domainMax * upperEps from domainMax,
positiveXOnly  [o] this only applies to lowerEps and only if an added point would be negative when domainMin is non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the y value at x.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with ts y-values set to exp( a * [self’s y-values] ). x-values are added to meet required accuaracy.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getAccuracy">
<code class="sig-name descname">getAccuracy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getAccuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self’s accuracy value.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getBiSectionMax">
<code class="sig-name descname">getBiSectionMax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getBiSectionMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self’s biSectionMax value.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getInfill">
<code class="sig-name descname">getInfill</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getInfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self’s infill flag.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getInterpolation">
<code class="sig-name descname">getInterpolation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self’s interpolation as a string.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getNFStatus">
<code class="sig-name descname">getNFStatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getNFStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self’s numerical functions status flag (an integer).</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getSafeDivide">
<code class="sig-name descname">getSafeDivide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getSafeDivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns self’s safeDivide flag.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getSecondaryCacheSize">
<code class="sig-name descname">getSecondaryCacheSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getSecondaryCacheSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of self’s secondary cache.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getUserFlag">
<code class="sig-name descname">getUserFlag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getUserFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the user flag.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getslice">
<code class="sig-name descname">getslice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lowerIndex</span></em>, <em class="sig-param"><span class="n">upperIndex</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.getslice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the slice of self from lowerIndex to upperIndex with a step of 1.</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>lowerIndex [o]      Value of the lower index. Default is 0.
upperIndex [o]      Value of the upper index. Default is length of pointwiseXY_C.</p>
</dd>
</dl>
<p>Example: Return a pointwise representation of ‘x * sin( x**2 )’ in the domain [1, 10].</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupOneFunction">
<code class="sig-name descname">groupOneFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupOneFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list of float values. Each value is the integral of self between two consecutive group boundaries.</p>
<dl>
<dt>Arguments are:</dt><dd><p>groupBoundaries     the list of group boundaries,
norm                each value returned can be normalized as directed by one of the following allowed values</p>
<blockquote>
<div><p>None                no normalization is applied,
‘dx’                each value is normalized by the width of its interval,
list                a list of floats, one each for each group which the group is normalized by.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupThreeFunctions">
<code class="sig-name descname">groupThreeFunctions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupThreeFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list of float values. Each value is the integral of the product of self, f2 and f3 between two consecutive group boundaries.</p>
<dl>
<dt>Arguments are:</dt><dd><p>f2                  the second pointwiseXY_C function with the integrand being the product of self * f2 * f3
f3                  the third pointwiseXY_C function with the integrand being the product of self * f2 * f3
groupBoundaries     the list of group boundaries,
norm                each value returned can be normalized as directed by one of the following allowed values</p>
<blockquote>
<div><p>None                no normalization is applied,
‘dx’                each value is normalized by the width of its interval,
list                a list of floats, one each for each group which the group is normalized by.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupTwoFunctions">
<code class="sig-name descname">groupTwoFunctions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.groupTwoFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list of float values. Each value is the integral of the product of self and f2 between two consecutive group boundaries.</p>
<dl>
<dt>Arguments are:</dt><dd><p>f2                  the second pointwiseXY_C function with the integrand being the product of self * f2
groupBoundaries     the list of group boundaries,
norm                each value returned can be normalized as directed by one of the following allowed values</p>
<blockquote>
<div><p>None                no normalization is applied,
‘dx’                each value is normalized by the width of its interval,
list                a list of floats, one each for each group which the group is normalized by.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns float a value that is the integral of self from domainMin to domainMax.</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>domainMin    [o] the lower limit of the integral, default is domainMin of self,
domainMax    [o] the upper limit of the integral, default is domainMax of self.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithFunction">
<code class="sig-name descname">integrateWithFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a float value that is the integral of self times f(x) for x from domainMin to domainMax (i.e. integral dx self(x) * f(x)). This method uses an adaptive method with a Gauss-Legendre quadrature to calculate the integral to tolerance. The first argument, func, must return the value of f(x) at x. func is called as func( x, parameters ) where parameters is the third argument to this method. The Gauss-Legendre quadrature is exact for any polynomial of degree n for which n &lt; degree where degree is one of the arguments. If recursionLimit is needed by the adaptive method, tolerance will, most likely, not be met.</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>func                a python function taking x and parameters as arguments and returning the value f(x),
tolerance           the desired tolerance for the integral,
parameters      [o] a python object passed passed to func [defalut=None],
domainMin            [o] the lower limit of the integral [default is domainMin of self],
domainMax            [o] the upper limit of the integral [default is domainMax of self],
degree          [o] the polynomial degree for which the Gauss-Legendre quadrature is exact [default=4],
recursionLimit  [o] the maximum recursion depth used in the adaptive quadrature [default=10].</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithWeight_sqrt_x">
<code class="sig-name descname">integrateWithWeight_sqrt_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithWeight_sqrt_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns float a value that is the integral of self weighted by sqrt( x ) from domainMin to domainMax (i.e. integral dx sqrt( x ) * self(x)).</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>domainMin    [o] the lower limit of the integral, default is domainMin of self,
domainMax    [o] the upper limit of the integral, default is domainMax of self.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithWeight_x">
<code class="sig-name descname">integrateWithWeight_x</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.integrateWithWeight_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns float a value that is the integral of self weighted by x from domainMin to domainMax (i.e. integral dx x * self(x)).</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>domainMin    [o] the lower limit of the integral, default is domainMin of self,
domainMax    [o] the upper limit of the integral, default is domainMax of self.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.inverse">
<code class="sig-name descname">inverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with the x- and y-values of self being the y- and x-values of the returned instance, respectively.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.isInterpolationLinear">
<code class="sig-name descname">isInterpolationLinear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.isInterpolationLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if self’s interpolation is ‘lin-lin’, otherwise returns False.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.isInterpolationOther">
<code class="sig-name descname">isInterpolationOther</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.isInterpolationOther" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if self’s interpolation is ‘other’, otherwise returns False.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.lowerIndexBoundingX">
<code class="sig-name descname">lowerIndexBoundingX</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.lowerIndexBoundingX" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lower index in self that bounds the x-value. -1 is returned if x is outside domain.</p>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>x       the x-value whose lower bounding index is return.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.mergeClosePoints">
<code class="sig-name descname">mergeClosePoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.mergeClosePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new pointwiseXY_C object whose x values are the union of self and other.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.mutualify">
<code class="sig-name descname">mutualify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.mutualify" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a python list containing two pointwiseXY_C instances that are the mutualification of self and other.
Mutualification is the act of modifying, if needed, two pointwiseXY_C instances so that their domains are mutual.
Self and other are not altered.</p>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>lowerEps1       the lowerEps applied to self if needed, see dullEdges for meaning,
upperEps1       the upperEps applied to self if needed, see dullEdges for meaning,
positiveXOnly1  the positiveXOnly applied to self if needed, see dullEdges for meaning,
other           the second pointwiseXY_C instance to mutualify self with,
lowerEps2       the lowerEps applied to other if needed, see dullEdges for meaning,
upperEps2       the upperEps applied to other if needed, see dullEdges for meaning,
positiveXOnly2  the positiveXOnly applied to other if needed, see dullEdges for meaning,</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.normalize">
<code class="sig-name descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with the same x-values as self but with the y-values scaled so that the area of the curve is 1.</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>insitu  [o] If True, self is normalize and returned. Otherwise, a new instances is created and normalize and self is unchanged.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.overflowAllocatedSize">
<code class="sig-name descname">overflowAllocatedSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.overflowAllocatedSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of memory allocated for the overflow region.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.overflowLength">
<code class="sig-name descname">overflowLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.overflowLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns of number of points in the overflow region.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls Gnuplot, if it exists, to plot self. This is a simple method, mainly for debugging.</p>
<p>Arguments: None.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.pop">
<code class="sig-name descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes and returns point at index (default last).</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.range">
<code class="sig-name descname">range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.range" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimum and maximum y-values in self or 0 if self is empty.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.rangeMax">
<code class="sig-name descname">rangeMax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.rangeMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum y-value in self or 0 if self is empty.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.rangeMin">
<code class="sig-name descname">rangeMin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.rangeMin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimum y-value in self or 0 if self is empty.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.reallocateOverflowPoints">
<code class="sig-name descname">reallocateOverflowPoints</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.reallocateOverflowPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusts the memory allocated for the overflow points to size (the first and only argument).</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.reallocatePoints">
<code class="sig-name descname">reallocatePoints</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">size</span></em>, <em class="sig-param"><span class="n">forceSmaller</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.reallocatePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusts the memory allocated for primary points to the maximum of size and the current length of self.</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>size              the desired allocated size of self (actual size will be larger if length is greater than size),
forceSmaller  [o] if False action is only taken if allocated is significantly greater than size (default is True).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.runningIntegral">
<code class="sig-name descname">runningIntegral</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.runningIntegral" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns, as a python list, the integrals between successive x-values.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.scaleOffsetXAndY">
<code class="sig-name descname">scaleOffsetXAndY</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.scaleOffsetXAndY" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new pointwiseXY_C object whose x and y values are scaled and offset.</p>
<dl>
<dt>Arguments are: ([o] implies optional argument)</dt><dd><blockquote>
<div><p>xScale   [o] the scale for the x-axis,
xOffset  [o] the offset for the x-axis,
yScale   [o] the scale for the y-axis,
yOffset  [o] the offset for the y-axis,
insitu   [o] If True, self is scalled and offset and returned.</p>
</div></blockquote>
<p>Otherwise, a new instances is created and returned, and self is unchanged.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setAccuracy">
<code class="sig-name descname">setAccuracy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setAccuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets self’s accuracy value and returns the actual value set.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setBiSectionMax">
<code class="sig-name descname">setBiSectionMax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setBiSectionMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets self’s biSectionMax value and returns the actual value set.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setData">
<code class="sig-name descname">setData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setData" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the data in self with the frist argument. This argument must be a list. Each item of the list must contain two floats, or objects that can be convert to float (e.g., [ [ 1, 2 ], [ 2, 4 ], [ 4, 0.5 ] ]</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setDataFromList">
<code class="sig-name descname">setDataFromList</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setDataFromList" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the data in self with the python list given by the first argument.</p>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>xys      the list of xy-values as a single python list (e.g., [ 1, 2, 4, 3, 5, 6]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setDataFromXsAndYs">
<code class="sig-name descname">setDataFromXsAndYs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setDataFromXsAndYs" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the data in self with the 2 python lists given by the first 2 arguments.</p>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>xs      the list of x-values
ys      the list of y-values</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setInfill">
<code class="sig-name descname">setInfill</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setInfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets self’s infill flag to the first argument.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setInterpolation">
<code class="sig-name descname">setInterpolation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Set self’s interpolation. Other interpolation not supported.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setSafeDivide">
<code class="sig-name descname">setSafeDivide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setSafeDivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets self’s safeDivide flag to the first argument.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setSecondaryCacheSize">
<code class="sig-name descname">setSecondaryCacheSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setSecondaryCacheSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the size of self’s secondary cache to size.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setUserFlag">
<code class="sig-name descname">setUserFlag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setUserFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the users flag via the first argument.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setValue">
<code class="sig-name descname">setValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.setValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the y value at x.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.showInteralStructure">
<code class="sig-name descname">showInteralStructure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.showInteralStructure" title="Permalink to this definition">¶</a></dt>
<dd><p>For debbuging only. Dumps information on internal data.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thicken">
<code class="sig-name descname">thicken</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thicken" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with denser points than self filled in using self’s interpolation. The number of points added are determined by the following arguments
sectionSubdivideMax    maximum number of points to insert between consecutive points (default 1),
dDomainMax             minimum dx step (default 0),
fDomainMax             minimum fractional step (default 1).</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thin">
<code class="sig-name descname">thin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance of self thinned to accuracy (i.e., points are removed if possible).</p>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>accuracy        The accuracy to maintain for the function when thinning.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thinDomain">
<code class="sig-name descname">thinDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.thinDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance of self with fractional x-spacing between points of at least
epsilon. Points are removed if needed. Fractional x-spacing is defined as</p>
<blockquote>
<div><p>( x_{i+1} - x_i ) / ( fabs( x_{i+1} ) - fabs( x_i ) ).</p>
</div></blockquote>
<dl class="simple">
<dt>Arguments are:</dt><dd><p>epsilon      The fraction minimum distance between sequential x-value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.toString">
<code class="sig-name descname">toString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.toString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representation of self. This method has three keyword parameters:
pairsPerLine, format and pairSeparator which are defined as,</p>
<blockquote>
<div><p>pairsPerLine    the number of pairs to put on each line
format          a valid format to convert an (x,y) pair (i.e., two floats) into a string (e.g. format = ‘ %.3f %12.5e’)
pairSeparator   a string to put between every pair (e.g, to put a comma to separate pairs use pairSeparator = ‘,’)</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.trim">
<code class="sig-name descname">trim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.trim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance with excessive 0. y-value points at beginning and end of self removed.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.union">
<code class="sig-name descname">union</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new pointwiseXY_C object whose x values are the union of self and other.</p>
</dd></dl>

<dl class="py method">
<dt id="numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.ysMappedToXs">
<code class="sig-name descname">ysMappedToXs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#numericalFunctions.lib.pointwiseXY_C.pointwiseXY_C.ysMappedToXs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the tuple (offset, y-values) where y-values is self’s y-values mapped to Xs.</p>
<dl class="simple">
<dt>Arguments are: ([o] implies optional argument)</dt><dd><p>Xs  [o] List of x-values to map self to.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/gnd.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">numericalFunctions Package</a><ul>
<li><a class="reference internal" href="#specialfunctions-module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">specialFunctions</span></code> Module</a></li>
<li><a class="reference internal" href="#legendre-module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Legendre</span></code> Module</a></li>
<li><a class="reference internal" href="#module-numericalFunctions.lib.pointwiseXY_C"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pointwiseXY_C</span></code> Module</a></li>
<li><a class="reference internal" href="#pointwisexy-c-pointwisexy-c-class"><code class="xref py py-class docutils literal notranslate"><span class="pre">pointwiseXY_C.pointwiseXY_C</span></code> Class</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="fudge.vis.matplotlib.html"
                        title="previous chapter">fudge.vis.matplotlib package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../externals.html"
                        title="next chapter">External Packages used in Fudge</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/fudge/numericalFunctions.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../externals.html" title="External Packages used in Fudge"
             >next</a> |</li>
        <li class="right" >
          <a href="fudge.vis.matplotlib.html" title="fudge.vis.matplotlib package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Fudge and GNDS 4.2.3 beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >fudge Package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">numericalFunctions Package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, B.Beck, D. Brown, C. Mattoon, N. Patel, N. Summers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>