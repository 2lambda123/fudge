
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>fudge.processing.resonances.fudgeReconstructResonances &mdash; Fudge and GND 1.2 beta documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.2 beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/gnd-20121206-favicon.ico"/>
    <link rel="top" title="Fudge and GND 1.2 beta documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">Fudge and GND 1.2 beta documentation</a> &raquo;</li>
          <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for fudge.processing.resonances.fudgeReconstructResonances</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c">#encoding: utf-8</span>

<span class="c"># &lt;&lt;BEGIN-copyright&gt;&gt;</span>
<span class="c"># Copyright (c) 2011, Lawrence Livermore National Security, LLC.</span>
<span class="c"># Produced at the Lawrence Livermore National Laboratory.</span>
<span class="c"># Written by the LLNL Computational Nuclear Physics group</span>
<span class="c">#         (email: mattoon1@llnl.gov)</span>
<span class="c"># LLNL-CODE-494171 All rights reserved.</span>
<span class="c"># </span>
<span class="c"># This file is part of the FUDGE package (For Updating Data and </span>
<span class="c">#         Generating Evaluations)</span>
<span class="c"># </span>
<span class="c"># </span>
<span class="c">#     Please also read this link - Our Notice and GNU General Public License.</span>
<span class="c"># </span>
<span class="c"># This program is free software; you can redistribute it and/or modify it under </span>
<span class="c"># the terms of the GNU General Public License (as published by the Free Software</span>
<span class="c"># Foundation) version 2, dated June 1991.</span>
<span class="c"># This program is distributed in the hope that it will be useful, </span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF MERCHANTABILITY </span>
<span class="c"># or FITNESS FOR A PARTICULAR PURPOSE. See the terms and conditions of </span>
<span class="c"># the GNU General Public License for more details.</span>
<span class="c"># You should have received a copy of the GNU General Public License along with </span>
<span class="c"># this program; if not, write to </span>
<span class="c"># </span>
<span class="c"># the Free Software Foundation, Inc.,</span>
<span class="c"># 59 Temple Place, Suite 330,</span>
<span class="c"># Boston, MA 02111-1307 USA</span>
<span class="c"># &lt;&lt;END-copyright&gt;&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">reconstruct resonance region</span>
<span class="sd">cmattoon, 12/1/2010</span>

<span class="sd">See ENDF-102 (endf documentation) appendix D for equations</span>

<span class="sd">Basic usage:</span>

<span class="sd">    if x is a reactionSuite instance,</span>

<span class="sd">        &gt;&gt;xsecs = fudgeReconstructResonances.reconstructResonances(x, tolerance=0.01)</span>

<span class="sd">    This reconstructs all resolved/unresolved resonance sections. In each section,</span>
<span class="sd">    the results are accurate under linear interpolation to tolerance of 1% or better.</span>
<span class="sd">    All sections are summed together.</span>

<span class="sd">    * xsecs = dictionary containing cross sections: {&#39;total&#39;:XYs, &#39;elastic&#39;:XYs, ...}</span>
<span class="sd">    each cross section is an XYs class instance, containing data and also axes with units</span>


<span class="sd">Alternate use:</span>

<span class="sd">    If desired, reconstruct a single section:</span>

<span class="sd">    &gt;&gt; resCls = fudgeReconstructResonances.RMcrossSection(x)   # for Reich_Moore</span>
<span class="sd">    &gt;&gt; energy_grid = s.generateEnergyGrid()</span>
<span class="sd">    &gt;&gt; crossSections = s.getCrossSection( energy_grid )</span>
<span class="sd">    # the input to getCrossSection is the energy (or list of energies) in eV</span>
<span class="sd">    # crossSections are returned as a dictionary {&#39;total&#39;:,&#39;elastic&#39;:,&#39;capture&#39;:,&#39;fission&#39;:,}</span>

<span class="sd">    # improve grid to desired tolerance for linear interpolation:</span>
<span class="sd">    &gt;&gt; new_energy_grid, new_crossSections, messages = s.refineInterpolation(energy_grid, crossSections, tolerance=0.01)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">fudge.gnd.reactionData</span> <span class="kn">import</span> <span class="n">crossSection</span>

<span class="n">__metaclass__</span> <span class="o">=</span> <span class="nb">type</span>


<div class="viewcode-block" id="reconstructResonances"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.reconstructResonances">[docs]</a><span class="k">def</span> <span class="nf">reconstructResonances</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; reconstruct all resonance sections (resolved/unresolved) in reactionSuite, </span>
<span class="sd">    add results together for full (resonance region) pointwise cross section.</span>
<span class="sd">    If tolerance is specified, refine grid to required tolerance for (lin-lin) interpolation &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">reconstructCrossSection</span><span class="p">:</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;      Resonance reconstruction was already done. Reconstruct again? y/N&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">raw_input</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">xsecs</span>
    
    <span class="n">egrids</span><span class="p">,</span> <span class="n">xsecs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">resolvedReconstruct</span><span class="p">(</span> <span class="n">nativeData</span><span class="p">,</span> <span class="n">sectionIndex</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">nativeData</span><span class="o">.</span><span class="n">moniker</span> <span class="o">==</span> <span class="s">&#39;SingleLevel_BreitWigner&#39;</span><span class="p">:</span> <span class="n">resCls</span> <span class="o">=</span> <span class="n">SLBWcrossSection</span>
            <span class="k">elif</span> <span class="n">nativeData</span><span class="o">.</span><span class="n">moniker</span> <span class="o">==</span> <span class="s">&#39;MultiLevel_BreitWigner&#39;</span><span class="p">:</span> <span class="n">resCls</span> <span class="o">=</span> <span class="n">MLBWcrossSection</span>
            <span class="k">elif</span> <span class="n">nativeData</span><span class="o">.</span><span class="n">moniker</span> <span class="o">==</span> <span class="s">&#39;Reich_Moore&#39;</span><span class="p">:</span> <span class="n">resCls</span> <span class="o">=</span> <span class="n">RMcrossSection</span>
            <span class="k">elif</span> <span class="n">nativeData</span><span class="o">.</span><span class="n">moniker</span> <span class="o">==</span> <span class="s">&#39;R_Matrix_Limited&#39;</span><span class="p">:</span> <span class="n">resCls</span> <span class="o">=</span> <span class="n">RMatrixLimitedcrossSection</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="s">&quot;Don&#39;t recognize resonance type </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nativeData</span><span class="o">.</span><span class="n">moniker</span>
            <span class="n">reconstructClass</span> <span class="o">=</span> <span class="n">resCls</span><span class="p">(</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">,</span> <span class="n">verbose</span> <span class="p">)</span>
            <span class="n">egrid</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">()</span>
            <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span> <span class="n">egrid</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs_now</span><span class="p">,</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">refineInterpolation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">xsecs_now</span><span class="p">,</span>
                        <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span> <span class="k">print</span> <span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs_now</span>
        
        <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">multipleRegions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span> <span class="s">&quot;      WARNING! Multiple resolved/unresolved energy regions are deprecated</span><span class="se">\n</span><span class="s">&quot;</span>
                        <span class="o">+</span><span class="s">&quot;        and should be consolidated into single section&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">RRidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">)):</span>
                <span class="n">nativeData</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">RRidx</span><span class="p">]</span><span class="o">.</span><span class="n">nativeData</span>
                <span class="n">egrid_now</span><span class="p">,</span> <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">nativeData</span><span class="p">,</span> <span class="n">RRidx</span> <span class="p">)</span>
                <span class="c"># merge with &#39;full&#39; energy grid:</span>
                <span class="n">egrids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">egrid_now</span> <span class="p">)</span>
                <span class="n">xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs_now</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nativeData</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">nativeData</span>
            <span class="n">egrid_now</span><span class="p">,</span> <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">nativeData</span> <span class="p">)</span>
            <span class="c"># merge with &#39;full&#39; energy grid:</span>
            <span class="n">egrids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">egrid_now</span> <span class="p">)</span>
            <span class="n">xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs_now</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span><span class="p">:</span>
        <span class="n">nativeData</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span><span class="o">.</span><span class="n">nativeData</span>
        <span class="n">reconstructClass</span> <span class="o">=</span> <span class="n">URRcrossSection</span><span class="p">(</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">verbose</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">nativeData</span><span class="o">.</span><span class="n">forSelfShieldingOnly</span><span class="p">:</span> <span class="c"># don&#39;t reconstruct</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Skipping unresolved: for self shielding only&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span> <span class="p">)</span>

            <span class="k">if</span> <span class="bp">False</span> <span class="ow">and</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="c"># Disabling this section since ENDF manual now states that we should interpolate cross sections rather than parameters for URR.</span>
                <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs_now</span><span class="p">,</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">refineInterpolation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">xsecs_now</span><span class="p">,</span>
                        <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span> <span class="k">print</span> <span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="c"># meld with resolved region:</span>
            <span class="n">egrids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">None</span> <span class="p">)</span>
            <span class="n">xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs_now</span> <span class="p">)</span>

    <span class="c"># &#39;xsecs&#39; list now holds one or more regions. Convert to pointwise or piecewise cross section instance:</span>
    <span class="n">xsecs_final</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xsecs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>   <span class="c"># only one region: treat as pointwise</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">pointwise</span> <span class="p">):</span> <span class="n">xsecs_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axes_</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">pointwise</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">()</span>
                <span class="n">xsecs_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">pointwise</span><span class="p">(</span> <span class="n">axes_</span><span class="p">,</span> <span class="p">(</span><span class="n">egrids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]),</span> <span class="n">dataForm</span><span class="o">=</span><span class="s">&quot;XsAndYs&quot;</span><span class="p">,</span>
                        <span class="n">accuracy</span><span class="o">=</span><span class="p">(</span><span class="n">tolerance</span> <span class="ow">or</span> <span class="mf">0.01</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>               <span class="c"># multiple regions: treat as piecewise</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">pwxs</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">piecewise</span><span class="p">(</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">piecewise</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">()</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xsecs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">xsecs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">pointwise</span> <span class="p">):</span> <span class="n">xys</span> <span class="o">=</span> <span class="n">xsecs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">axes_</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">pointwise</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">()</span>
                    <span class="n">xys</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">pointwise</span><span class="p">(</span> <span class="n">axes_</span><span class="p">,</span> <span class="p">(</span><span class="n">egrids</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">xsecs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">]),</span> <span class="n">dataForm</span><span class="o">=</span><span class="s">&quot;XsAndYs&quot;</span><span class="p">,</span>
                            <span class="n">accuracy</span><span class="o">=</span><span class="p">(</span><span class="n">tolerance</span> <span class="ow">or</span> <span class="mf">0.01</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">pwxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xys</span> <span class="p">)</span>
            <span class="n">xsecs_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pwxs</span>

    <span class="c"># note that this does not add pointwise (ENDF-MF3) portion.</span>
    <span class="c"># Use gnd.reactionSuite.reconstructResonances for that</span>
    <span class="k">return</span> <span class="n">xsecs_final</span>


<span class="c"># base class common to resolved and unresolved resonance reconstruction</span></div>
<div class="viewcode-block" id="resonanceReconstructionBaseClass"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.resonanceReconstructionBaseClass">[docs]</a><span class="k">class</span> <span class="nc">resonanceReconstructionBaseClass</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projectile</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">projectile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">getSpin</span><span class="p">()</span><span class="o">.</span><span class="n">value</span>
        <span class="n">neutronMass</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">getParticle</span><span class="p">(</span> <span class="s">&#39;n&#39;</span> <span class="p">)</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetToNeutronMassRatio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">neutronMass</span>
    
<div class="viewcode-block" id="resonanceReconstructionBaseClass.k"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.resonanceReconstructionBaseClass.k">[docs]</a>    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">):</span>
        <span class="c"># sqrt(2*neutronMass)/hbar == 2.196807 (eV*barn)**-1/2. Thus for energy in eV, k is in b**-1/2</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.196807122623e-3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetToNeutronMassRatio</span> <span class="o">/</span> 
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetToNeutronMassRatio</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">energy</span><span class="p">))</span>
    </div>
    <span class="sd">&quot;&quot;&quot; refer to SAMMY manual page 9 for penetration/shift/phase factor equations: &quot;&quot;&quot;</span>
<div class="viewcode-block" id="resonanceReconstructionBaseClass.penetrationFactor"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.resonanceReconstructionBaseClass.penetrationFactor">[docs]</a>    <span class="k">def</span> <span class="nf">penetrationFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">L</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">5</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">7</span> <span class="o">/</span> <span class="p">(</span><span class="mi">225</span><span class="o">+</span><span class="mi">45</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">9</span> <span class="o">/</span> <span class="p">(</span><span class="mi">11025</span><span class="o">+</span><span class="mi">1575</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">135</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="c"># find it recursively</span>
            <span class="n">P_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">P_Lminus1</span> <span class="o">/</span> <span class="p">((</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">P_Lminus1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="resonanceReconstructionBaseClass.shiftFactor"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.resonanceReconstructionBaseClass.shiftFactor">[docs]</a>    <span class="k">def</span> <span class="nf">shiftFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate shift factor used in SLBW and MLBW formalisms &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">L</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">rho</span>   <span class="c"># rho may be an array</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="mf">18.0</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="mf">675.0</span><span class="o">+</span><span class="mi">90</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">225</span><span class="o">+</span><span class="mi">45</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="p">(</span> <span class="p">(</span><span class="mf">44100.0</span><span class="o">+</span><span class="mi">4725</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">270</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span> <span class="o">/</span> 
                <span class="p">(</span><span class="mi">11025</span><span class="o">+</span><span class="mi">1575</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">135</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="n">P_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">P_Lminus1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="resonanceReconstructionBaseClass.phi"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.resonanceReconstructionBaseClass.phi">[docs]</a>    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="c"># calculate hard-sphere phase-shift</span>
        <span class="k">if</span> <span class="n">L</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="mi">15</span><span class="o">-</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">15</span><span class="o">-</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="mi">105</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">105</span><span class="o">-</span><span class="mi">45</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="n">P_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">phi_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">phi_Lminus1</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">P_Lminus1</span> <span class="o">/</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">))</span>
    
    <span class="c"># for use after the cross section has been calculated on the initial grid:</span></div>
<div class="viewcode-block" id="resonanceReconstructionBaseClass.refineInterpolation"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.resonanceReconstructionBaseClass.refineInterpolation">[docs]</a>    <span class="k">def</span> <span class="nf">refineInterpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; generateEnergyGrid may not give a fine enough grid to linearly interpolate to desired tolerance.</span>
<span class="sd">        My solution to that: for all consecutive points (x0,y0), (x1,y1) and (x2,y2) do a linear interpolation between</span>
<span class="sd">        (x0,y0) and (x2,y2). If the interpolation doesn&#39;t agree with (x1,y1) within tolerance,</span>
<span class="sd">        subdivide up the region by adding two more calculated points.  Keep iterating until interpolation agrees within tolerance.</span>
<span class="sd">        </span>
<span class="sd">        This means that in the end we will have more points than required for given tolerance.</span>
<span class="sd">        The results can be thinned (implemented in XYs)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">checkInterpolation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; do a linear interpolation of each point from its two nearest neighbors</span>
<span class="sd">            then check where the interpolation is insufficient</span>
<span class="sd">            x,y must be numpy arrays</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">delta_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

            <span class="c"># add first and last points back in, for easier comparison with</span>
            <span class="c"># original y values:</span>
            <span class="n">interpolated</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">interpolated</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">delta_x</span><span class="o">+</span><span class="n">b</span>
            <span class="n">interpolated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">interpolated</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># find where original and interpolated grids differ by more than tolerance</span>
            <span class="c"># silence div/0 warnings for this step, since xsc = 0 case is explicitly handled below</span>
            <span class="n">olderr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span> <span class="n">divide</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span> <span class="p">)</span>
            <span class="n">delt</span> <span class="o">=</span> <span class="n">interpolated</span> <span class="o">/</span> <span class="n">y</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span> <span class="o">**</span><span class="n">olderr</span> <span class="p">)</span>    <span class="c"># re-enable div/0 warnings</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">delt</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">+</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">delt</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">-</span><span class="n">tolerance</span><span class="p">)</span> <span class="c"># boolean array</span>
            <span class="n">badindices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">))[</span> <span class="n">mask</span> <span class="p">]</span>
            <span class="c"># at these points, we need a finer mesh</span>

            <span class="c"># use absolute convergence condition at or near xsc = 0:</span>
            <span class="n">zeros</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">badindices</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">badindices</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">badindices</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">zeros</span><span class="p">):</span>
                <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">badindices</span><span class="p">[</span> <span class="n">zeros</span> <span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-3</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-3</span><span class="p">:</span>
                        <span class="n">mask</span><span class="p">[</span> <span class="n">idx</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">ignore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">idx</span> <span class="p">)</span>
                <span class="n">badindices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">badindices</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">badindices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="n">midpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">energies_needed</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span> <span class="n">midpoints</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span> <span class="n">midpoints</span><span class="p">[</span><span class="n">mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">badindices</span><span class="p">,</span> <span class="n">energies_needed</span>

        <span class="k">def</span> <span class="nf">mergeArrays</span><span class="p">(</span> <span class="n">newIdx</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="p">):</span>
            <span class="c"># from the list of &#39;bad&#39; points in original array x1, obtain two new integer arrays, a1 and a2,</span>
            <span class="c"># containing indices to insert x1 and x2 into merged array. Use these to quickly merge all data:</span>
            <span class="n">newLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
            <span class="n">a1</span><span class="p">,</span><span class="n">a2</span> <span class="o">=</span> <span class="p">[],[]</span>
            <span class="n">nic</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span> <span class="n">newIdx</span> <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newIdx</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">idnow</span><span class="p">,</span> <span class="n">idnext</span> <span class="o">=</span> <span class="n">nic</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">idnow</span><span class="p">,</span> <span class="n">idnext</span> <span class="o">=</span> <span class="n">nic</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">nic</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="n">current</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">idnow</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">extraPoint</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">newLen</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">val</span><span class="o">==</span><span class="n">current</span><span class="p">:</span>
                    <span class="n">a2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">idnext</span><span class="o">==</span><span class="n">idnow</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">current</span><span class="o">=</span><span class="n">idnext</span> <span class="o">+</span> <span class="n">offset</span>
                        <span class="n">idnow</span> <span class="o">=</span> <span class="n">idnext</span>
                        <span class="k">try</span><span class="p">:</span> <span class="n">idnext</span> <span class="o">=</span> <span class="n">nic</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span> <span class="n">idnext</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">extraPoint</span><span class="p">:</span>
                        <span class="n">extraPoint</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">current</span><span class="o">=</span><span class="n">idnext</span> <span class="o">+</span> <span class="n">offset</span>
                        <span class="n">idnow</span> <span class="o">=</span> <span class="n">idnext</span>
                        <span class="k">try</span><span class="p">:</span> <span class="n">idnext</span> <span class="o">=</span> <span class="n">nic</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span> <span class="n">idnext</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">extraPoint</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">current</span> <span class="o">+=</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c"># a1 and a2 now hold the indices for inserting x1 and x2 into merged array</span>
            <span class="n">xnew</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newLen</span><span class="p">)</span>
            <span class="n">xnew</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span> <span class="n">xnew</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2</span>
            <span class="n">ynew</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">y1</span><span class="p">:</span>
                <span class="n">ynew</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newLen</span><span class="p">)</span>
                <span class="n">ynew</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">a1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">key</span><span class="p">];</span> <span class="n">ynew</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">a2</span><span class="p">]</span> <span class="o">=</span> <span class="n">y2</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span>

        <span class="n">messages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">reactionDone</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">xsecs</span><span class="p">)</span>  <span class="c"># values are None</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">addedPoints</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">newX</span><span class="p">,</span> <span class="n">newIdx</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">reactionDone</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">badindices</span><span class="p">,</span> <span class="n">energies_needed</span> <span class="o">=</span> <span class="n">checkInterpolation</span><span class="p">(</span><span class="n">egrid</span><span class="p">,</span><span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">energies_needed</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">reactionDone</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">newIdx</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">badindices</span> <span class="p">)</span>
                    <span class="n">newX</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">energies_needed</span> <span class="p">)</span>
            <span class="n">newX</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
            <span class="n">newIdx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">newIdx</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>    <span class="c"># success!</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Iteration limit exceeded when refining interpolation grid!&quot;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">addedPoints</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
            <span class="n">newY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span> <span class="n">newX</span> <span class="p">)</span>
            <span class="c"># merge new x/y values with original list:</span>
            <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs</span> <span class="o">=</span> <span class="n">mergeArrays</span><span class="p">(</span> <span class="n">newIdx</span><span class="p">,</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">newX</span><span class="p">,</span> <span class="n">xsecs</span><span class="p">,</span> <span class="n">newY</span> <span class="p">)</span>

        <span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%i</span><span class="s"> points were added (for total of </span><span class="si">%i</span><span class="s">) to achieve tolerance of </span><span class="si">%s%%</span><span class="s">&quot;</span> <span class="o">%</span> 
            <span class="p">(</span><span class="n">addedPoints</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">tolerance</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs</span><span class="p">,</span> <span class="n">messages</span>


<span class="c">#### base class for resolved resonance reconstruction ####</span></div></div>
<div class="viewcode-block" id="RRBaseClass"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RRBaseClass">[docs]</a><span class="k">class</span> <span class="nc">RRBaseClass</span><span class="p">(</span><span class="n">resonanceReconstructionBaseClass</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot; store resonance parameters in convenient structure for quick cross section calculations: &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sectionIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># energy boundaries for this region (multiple regions are deprecated):</span>
            <span class="n">energyRegion</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">sectionIndex</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RR</span> <span class="o">=</span> <span class="n">energyRegion</span><span class="o">.</span><span class="n">nativeData</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">=</span> <span class="n">energyRegion</span><span class="o">.</span><span class="n">lowerBound</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">=</span> <span class="n">energyRegion</span><span class="o">.</span><span class="n">upperBound</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># only one energy region:</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">RR</span> <span class="o">=</span> <span class="n">resolved</span><span class="o">.</span><span class="n">nativeData</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">=</span> <span class="n">resolved</span><span class="o">.</span><span class="n">lowerBound</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">=</span> <span class="n">resolved</span><span class="o">.</span><span class="n">upperBound</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
    
<div class="viewcode-block" id="RRBaseClass.sortLandJ"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RRBaseClass.sortLandJ">[docs]</a>    <span class="k">def</span> <span class="nf">sortLandJ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        SLBW, MLBW and Reich_Moore formalisms have similar structure</span>
<span class="sd">        it&#39;s convenient to sort their resonances by L and J</span>
<span class="sd">        This method should NOT be used for R-Matrix Limited</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># make a unified table of resonance parameter data, convert to eV if necessary</span>
        <span class="n">nRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span> <span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;energy&#39;</span><span class="p">,</span><span class="s">&#39;L&#39;</span><span class="p">,</span><span class="s">&#39;J&#39;</span><span class="p">,</span><span class="s">&#39;channelSpin&#39;</span><span class="p">,</span><span class="s">&#39;totalWidth&#39;</span><span class="p">,</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s">&#39;captureWidth&#39;</span><span class="p">,</span>
                <span class="s">&#39;fissionWidthA&#39;</span><span class="p">,</span><span class="s">&#39;fissionWidthB&#39;</span><span class="p">)</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="p">)</span> <span class="k">for</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">units</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nRes</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">data</span> <span class="p">)</span>

        <span class="c"># sort resonances by L and J, store parameters in numpy arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Llist</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span> <span class="n">Llist</span> <span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">Lres</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="p">:,</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">)</span> <span class="p">]</span><span class="o">==</span><span class="n">L</span> <span class="p">]</span>
            <span class="n">Jlist</span> <span class="o">=</span> <span class="n">Lres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;J&#39;</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">Js</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Jlist</span><span class="p">)):</span>
                <span class="n">LJres</span> <span class="o">=</span> <span class="n">Lres</span><span class="p">[</span> <span class="p">:,</span> <span class="n">Lres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;J&#39;</span><span class="p">)</span> <span class="p">]</span><span class="o">==</span><span class="n">J</span> <span class="p">]</span>
                <span class="n">spinList</span> <span class="o">=</span> <span class="n">LJres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;channelSpin&#39;</span><span class="p">)</span> <span class="p">]</span>
                <span class="n">spins</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">spinList</span><span class="p">)):</span>
                    <span class="n">spinRes</span> <span class="o">=</span> <span class="n">LJres</span><span class="p">[</span> <span class="p">:,</span> <span class="n">LJres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;channelSpin&#39;</span><span class="p">)</span> <span class="p">]</span><span class="o">==</span><span class="n">spin</span> <span class="p">]</span>
                    <span class="n">energies</span> <span class="o">=</span> <span class="n">spinRes</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;energy&#39;</span><span class="p">)</span> <span class="p">]</span>
                    <span class="n">neutronWidth</span> <span class="o">=</span> <span class="p">(</span> <span class="n">spinRes</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">)</span> <span class="p">]</span> <span class="o">/</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">energies</span><span class="p">),</span><span class="n">L</span><span class="p">))</span> <span class="p">)</span>
                    <span class="c"># totalWidth = numpy.array([v(res.totalWidth) for res in LJres])</span>
                    <span class="n">spindict</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s">&#39;channelSpin&#39;</span><span class="p">:</span> <span class="n">spin</span><span class="p">,</span>
                            <span class="s">&#39;energy&#39;</span><span class="p">:</span> <span class="n">energies</span><span class="p">,</span>
                            <span class="s">&#39;neutronWidth&#39;</span><span class="p">:</span> <span class="n">neutronWidth</span><span class="p">,</span>
                            <span class="s">&#39;captureWidth&#39;</span><span class="p">:</span> <span class="n">spinRes</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;captureWidth&#39;</span><span class="p">)],</span>
                            <span class="s">&#39;fissionWidthA&#39;</span><span class="p">:</span> <span class="n">spinRes</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">)],</span>
                            <span class="s">&#39;fissionWidthB&#39;</span><span class="p">:</span> <span class="n">spinRes</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;fissionWidthB&#39;</span><span class="p">)],</span>
                            <span class="s">&#39;shiftFactor&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">energies</span><span class="p">))),</span>
                            <span class="p">}</span>
                    <span class="n">spins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">spindict</span> <span class="p">)</span>
                <span class="n">Jdict</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s">&#39;J&#39;</span><span class="p">:</span> <span class="n">J</span><span class="p">,</span>
                        <span class="s">&#39;gfact&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
                        <span class="s">&#39;channelSpins&#39;</span><span class="p">:</span> <span class="n">spins</span><span class="p">,</span>
                        <span class="p">}</span>
                <span class="n">Js</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Jdict</span> <span class="p">)</span>
            
            <span class="n">Ldict</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#39;L&#39;</span><span class="p">:</span> <span class="n">L</span><span class="p">,</span> <span class="s">&#39;Js&#39;</span><span class="p">:</span> <span class="n">Js</span> <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Ldict</span> <span class="p">)</span>

        <span class="c"># for each L, gfactors should sum to 2*L+1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">gsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span><span class="n">J</span><span class="p">[</span><span class="s">&#39;gfact&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="s">&#39;channelSpins&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s">&#39;Js&#39;</span><span class="p">]]</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">-</span> <span class="n">gsum</span>

        <span class="c"># for energy grid generation:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;energy&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">totalWidths</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;totalWidth&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">totalWidths</span><span class="p">):</span> <span class="c"># total widths aren&#39;t specified in Reich_Moore case</span>
            <span class="n">totalWidths</span> <span class="o">=</span> <span class="p">(</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;captureWidth&#39;</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;fissionWidthB&#39;</span><span class="p">)]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">=</span> <span class="n">totalWidths</span>
    </div>
<div class="viewcode-block" id="RRBaseClass.rho"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RRBaseClass.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># get the channel radius, rho. If L is specified try to get L-dependent value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10**-12*cm&#39;</span><span class="p">,</span> <span class="n">E</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10**-12*cm&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>
    </div>
<div class="viewcode-block" id="RRBaseClass.generateEnergyGrid"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RRBaseClass.generateEnergyGrid">[docs]</a>    <span class="k">def</span> <span class="nf">generateEnergyGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; create the energy grid by merging central resonance energies, fine mesh between resonances,</span>
<span class="sd">        and a rough mesh covering the entire region. use the total widths &quot;&quot;&quot;</span>
        <span class="n">energies</span><span class="p">,</span> <span class="n">widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span>
        <span class="n">lowBound</span><span class="p">,</span> <span class="n">highBound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span>
        <span class="c"># ignore negative resonances</span>
        <span class="k">for</span> <span class="n">lidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">energies</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">energies</span><span class="p">[</span><span class="n">lidx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="n">energies</span><span class="p">[</span><span class="n">lidx</span><span class="p">:]</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">lidx</span><span class="p">:]</span>
        <span class="c"># generate grid for a single peak, should be good to 1% using linear interpolation:</span>
        <span class="n">resonancePos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> 
            <span class="mf">0.000e+00</span><span class="p">,</span> <span class="mf">1.000e-03</span><span class="p">,</span> <span class="mf">2.000e-03</span><span class="p">,</span> <span class="mf">3.000e-03</span><span class="p">,</span> <span class="mf">4.000e-03</span><span class="p">,</span> <span class="mf">5.000e-03</span><span class="p">,</span> <span class="mf">6.000e-03</span><span class="p">,</span> <span class="mf">7.000e-03</span><span class="p">,</span> <span class="mf">8.000e-03</span><span class="p">,</span> <span class="mf">9.000e-03</span><span class="p">,</span> <span class="mf">1.000e-02</span><span class="p">,</span> <span class="mf">2.000e-02</span><span class="p">,</span>
            <span class="mf">3.000e-02</span><span class="p">,</span> <span class="mf">4.000e-02</span><span class="p">,</span> <span class="mf">5.000e-02</span><span class="p">,</span> <span class="mf">6.000e-02</span><span class="p">,</span> <span class="mf">7.000e-02</span><span class="p">,</span> <span class="mf">8.000e-02</span><span class="p">,</span> <span class="mf">9.000e-02</span><span class="p">,</span> <span class="mf">1.000e-01</span><span class="p">,</span> <span class="mf">1.100e-01</span><span class="p">,</span> <span class="mf">1.200e-01</span><span class="p">,</span> <span class="mf">1.300e-01</span><span class="p">,</span> <span class="mf">1.400e-01</span><span class="p">,</span>
            <span class="mf">1.500e-01</span><span class="p">,</span> <span class="mf">1.600e-01</span><span class="p">,</span> <span class="mf">1.700e-01</span><span class="p">,</span> <span class="mf">1.800e-01</span><span class="p">,</span> <span class="mf">1.900e-01</span><span class="p">,</span> <span class="mf">2.000e-01</span><span class="p">,</span> <span class="mf">2.100e-01</span><span class="p">,</span> <span class="mf">2.200e-01</span><span class="p">,</span> <span class="mf">2.300e-01</span><span class="p">,</span> <span class="mf">2.400e-01</span><span class="p">,</span> <span class="mf">2.500e-01</span><span class="p">,</span> <span class="mf">2.600e-01</span><span class="p">,</span>
            <span class="mf">2.800e-01</span><span class="p">,</span> <span class="mf">3.000e-01</span><span class="p">,</span> <span class="mf">3.200e-01</span><span class="p">,</span> <span class="mf">3.400e-01</span><span class="p">,</span> <span class="mf">3.600e-01</span><span class="p">,</span> <span class="mf">3.800e-01</span><span class="p">,</span> <span class="mf">4.000e-01</span><span class="p">,</span> <span class="mf">4.200e-01</span><span class="p">,</span> <span class="mf">4.400e-01</span><span class="p">,</span> <span class="mf">4.600e-01</span><span class="p">,</span> <span class="mf">4.800e-01</span><span class="p">,</span> <span class="mf">5.000e-01</span><span class="p">,</span>
            <span class="mf">5.500e-01</span><span class="p">,</span> <span class="mf">6.000e-01</span><span class="p">,</span> <span class="mf">6.500e-01</span><span class="p">,</span> <span class="mf">7.000e-01</span><span class="p">,</span> <span class="mf">7.500e-01</span><span class="p">,</span> <span class="mf">8.000e-01</span><span class="p">,</span> <span class="mf">8.500e-01</span><span class="p">,</span> <span class="mf">9.000e-01</span><span class="p">,</span> <span class="mf">9.500e-01</span><span class="p">,</span> <span class="mf">1.000e+00</span><span class="p">,</span> <span class="mf">1.050e+00</span><span class="p">,</span> <span class="mf">1.100e+00</span><span class="p">,</span>
            <span class="mf">1.150e+00</span><span class="p">,</span> <span class="mf">1.200e+00</span><span class="p">,</span> <span class="mf">1.250e+00</span><span class="p">,</span> <span class="mf">1.300e+00</span><span class="p">,</span> <span class="mf">1.350e+00</span><span class="p">,</span> <span class="mf">1.400e+00</span><span class="p">,</span> <span class="mf">1.450e+00</span><span class="p">,</span> <span class="mf">1.500e+00</span><span class="p">,</span> <span class="mf">1.550e+00</span><span class="p">,</span> <span class="mf">1.600e+00</span><span class="p">,</span> <span class="mf">1.650e+00</span><span class="p">,</span> <span class="mf">1.700e+00</span><span class="p">,</span>
            <span class="mf">1.750e+00</span><span class="p">,</span> <span class="mf">1.800e+00</span><span class="p">,</span> <span class="mf">1.850e+00</span><span class="p">,</span> <span class="mf">1.900e+00</span><span class="p">,</span> <span class="mf">1.950e+00</span><span class="p">,</span> <span class="mf">2.000e+00</span><span class="p">,</span> <span class="mf">2.050e+00</span><span class="p">,</span> <span class="mf">2.100e+00</span><span class="p">,</span> <span class="mf">2.150e+00</span><span class="p">,</span> <span class="mf">2.200e+00</span><span class="p">,</span> <span class="mf">2.250e+00</span><span class="p">,</span> <span class="mf">2.300e+00</span><span class="p">,</span>
            <span class="mf">2.350e+00</span><span class="p">,</span> <span class="mf">2.400e+00</span><span class="p">,</span> <span class="mf">2.450e+00</span><span class="p">,</span> <span class="mf">2.500e+00</span><span class="p">,</span> <span class="mf">2.600e+00</span><span class="p">,</span> <span class="mf">2.700e+00</span><span class="p">,</span> <span class="mf">2.800e+00</span><span class="p">,</span> <span class="mf">2.900e+00</span><span class="p">,</span> <span class="mf">3.000e+00</span><span class="p">,</span> <span class="mf">3.100e+00</span><span class="p">,</span> <span class="mf">3.200e+00</span><span class="p">,</span> <span class="mf">3.300e+00</span><span class="p">,</span>
            <span class="mf">3.400e+00</span><span class="p">,</span> <span class="mf">3.600e+00</span><span class="p">,</span> <span class="mf">3.800e+00</span><span class="p">,</span> <span class="mf">4.000e+00</span><span class="p">,</span> <span class="mf">4.200e+00</span><span class="p">,</span> <span class="mf">4.400e+00</span><span class="p">,</span> <span class="mf">4.600e+00</span><span class="p">,</span> <span class="mf">4.800e+00</span><span class="p">,</span> <span class="mf">5.000e+00</span><span class="p">,</span> <span class="mf">5.200e+00</span><span class="p">,</span> <span class="mf">5.400e+00</span><span class="p">,</span> <span class="mf">5.600e+00</span><span class="p">,</span>
            <span class="mf">5.800e+00</span><span class="p">,</span> <span class="mf">6.000e+00</span><span class="p">,</span> <span class="mf">6.200e+00</span><span class="p">,</span> <span class="mf">6.400e+00</span><span class="p">,</span> <span class="mf">6.500e+00</span><span class="p">,</span> <span class="mf">6.800e+00</span><span class="p">,</span> <span class="mf">7.000e+00</span><span class="p">,</span> <span class="mf">7.500e+00</span><span class="p">,</span> <span class="mf">8.000e+00</span><span class="p">,</span> <span class="mf">8.500e+00</span><span class="p">,</span> <span class="mf">9.000e+00</span><span class="p">,</span> <span class="mf">9.500e+00</span><span class="p">,</span>
            <span class="mf">1.000e+01</span><span class="p">,</span> <span class="mf">1.050e+01</span><span class="p">,</span> <span class="mf">1.100e+01</span><span class="p">,</span> <span class="mf">1.150e+01</span><span class="p">,</span> <span class="mf">1.200e+01</span><span class="p">,</span> <span class="mf">1.250e+01</span><span class="p">,</span> <span class="mf">1.300e+01</span><span class="p">,</span> <span class="mf">1.350e+01</span><span class="p">,</span> <span class="mf">1.400e+01</span><span class="p">,</span> <span class="mf">1.450e+01</span><span class="p">,</span> <span class="mf">1.500e+01</span><span class="p">,</span> <span class="mf">1.550e+01</span><span class="p">,</span>
            <span class="mf">1.600e+01</span><span class="p">,</span> <span class="mf">1.700e+01</span><span class="p">,</span> <span class="mf">1.800e+01</span><span class="p">,</span> <span class="mf">1.900e+01</span><span class="p">,</span> <span class="mf">2.000e+01</span><span class="p">,</span> <span class="mf">2.100e+01</span><span class="p">,</span> <span class="mf">2.200e+01</span><span class="p">,</span> <span class="mf">2.300e+01</span><span class="p">,</span> <span class="mf">2.400e+01</span><span class="p">,</span> <span class="mf">2.500e+01</span><span class="p">,</span> <span class="mf">2.600e+01</span><span class="p">,</span> <span class="mf">2.700e+01</span><span class="p">,</span>
            <span class="mf">2.800e+01</span><span class="p">,</span> <span class="mf">2.900e+01</span><span class="p">,</span> <span class="mf">3.000e+01</span><span class="p">,</span> <span class="mf">3.100e+01</span><span class="p">,</span> <span class="mf">3.200e+01</span><span class="p">,</span> <span class="mf">3.300e+01</span><span class="p">,</span> <span class="mf">3.400e+01</span><span class="p">,</span> <span class="mf">3.600e+01</span><span class="p">,</span> <span class="mf">3.800e+01</span><span class="p">,</span> <span class="mf">4.000e+01</span><span class="p">,</span> <span class="mf">4.200e+01</span><span class="p">,</span> <span class="mf">4.400e+01</span><span class="p">,</span>
            <span class="mf">4.600e+01</span><span class="p">,</span> <span class="mf">4.800e+01</span><span class="p">,</span> <span class="mf">5.000e+01</span><span class="p">,</span> <span class="mf">5.300e+01</span><span class="p">,</span> <span class="mf">5.600e+01</span><span class="p">,</span> <span class="mf">5.900e+01</span><span class="p">,</span> <span class="mf">6.200e+01</span><span class="p">,</span> <span class="mf">6.600e+01</span><span class="p">,</span> <span class="mf">7.000e+01</span><span class="p">,</span> <span class="mf">7.400e+01</span><span class="p">,</span> <span class="mf">7.800e+01</span><span class="p">,</span> <span class="mf">8.200e+01</span><span class="p">,</span>
            <span class="mf">8.600e+01</span><span class="p">,</span> <span class="mf">9.000e+01</span><span class="p">,</span> <span class="mf">9.400e+01</span><span class="p">,</span> <span class="mf">9.800e+01</span><span class="p">,</span> <span class="mf">1.020e+02</span><span class="p">,</span> <span class="mf">1.060e+02</span><span class="p">,</span> <span class="mf">1.098e+02</span><span class="p">,</span> <span class="mf">1.140e+02</span><span class="p">,</span> <span class="mf">1.180e+02</span><span class="p">,</span> <span class="mf">1.232e+02</span><span class="p">,</span> <span class="mf">1.260e+02</span><span class="p">,</span> <span class="mf">1.300e+02</span><span class="p">,</span>
            <span class="mf">1.382e+02</span><span class="p">,</span> <span class="mf">1.550e+02</span><span class="p">,</span> <span class="mf">1.600e+02</span><span class="p">,</span> <span class="mf">1.739e+02</span><span class="p">,</span> <span class="mf">1.800e+02</span><span class="p">,</span> <span class="mf">1.951e+02</span><span class="p">,</span> <span class="mf">2.000e+02</span><span class="p">,</span> <span class="mf">2.100e+02</span><span class="p">,</span> <span class="mf">2.189e+02</span><span class="p">,</span> <span class="mf">2.300e+02</span><span class="p">,</span> <span class="mf">2.456e+02</span><span class="p">,</span> <span class="mf">2.500e+02</span><span class="p">,</span>
            <span class="mf">2.600e+02</span><span class="p">,</span> <span class="mf">2.756e+02</span><span class="p">,</span> <span class="mf">3.092e+02</span><span class="p">,</span> <span class="mf">3.200e+02</span><span class="p">,</span> <span class="mf">3.469e+02</span><span class="p">,</span> <span class="mf">3.600e+02</span><span class="p">,</span> <span class="mf">3.892e+02</span><span class="p">,</span> <span class="mf">4.000e+02</span><span class="p">,</span> <span class="mf">4.200e+02</span><span class="p">,</span> <span class="mf">4.367e+02</span><span class="p">,</span> <span class="mf">4.600e+02</span><span class="p">,</span> <span class="mf">4.800e+02</span><span class="p">,</span>
            <span class="mf">5.000e+02</span><span class="p">,</span> <span class="mf">6.000e+02</span><span class="p">,</span> <span class="mf">7.000e+02</span><span class="p">,</span> <span class="mf">8.000e+02</span><span class="p">,</span> <span class="mf">9.000e+02</span><span class="p">,</span> <span class="mf">1.000e+03</span> <span class="p">])</span>
        
        <span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># get the midpoints (on log10 scale) between each resonance:</span>
        <span class="c"># emid = [lowBound] + list(10**( ( numpy.log10(energies[1:])+numpy.log10(energies[:-1]) ) / 2.0)) + [highBound]</span>
        <span class="c"># or get midpoints on linear scale:</span>
        <span class="n">emid</span> <span class="o">=</span> <span class="p">[</span><span class="n">lowBound</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="n">e1</span><span class="o">+</span><span class="n">e2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span><span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">energies</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">+</span> <span class="p">[</span><span class="n">highBound</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">lowedge</span><span class="p">,</span><span class="n">highedge</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span><span class="n">widths</span><span class="p">,</span><span class="n">emid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">emid</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">e</span><span class="o">-</span><span class="n">w</span><span class="o">*</span><span class="n">resonancePos</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lowedge</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">points</span><span class="o">&gt;</span><span class="n">lowedge</span><span class="p">])</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">e</span><span class="o">+</span><span class="n">w</span><span class="o">*</span><span class="n">resonancePos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">points</span><span class="o">&lt;</span><span class="n">highedge</span><span class="p">])</span>
        <span class="c"># also add rough grid, to cover any big gaps between resonances, should give at least 10 points per decade:</span>
        <span class="n">npoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">highBound</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowBound</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="n">grid</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowBound</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">highBound</span><span class="p">),</span> <span class="n">npoints</span><span class="p">)</span> <span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">grid</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lowBound</span><span class="p">,</span> <span class="n">highBound</span><span class="p">,</span> <span class="mf">0.0253</span><span class="p">]</span>   <span class="c"># region boundaries + thermal</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
        <span class="c"># toss any points outside of energy bounds:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span> <span class="n">grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lowBound</span><span class="p">)</span> <span class="p">:</span> <span class="n">grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">highBound</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">grid</span>

</div></div>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@blockwise: function decorator for improving performance in resolved region.</span>
<span class="sd">Each &#39;getCrossSection&#39; method is wrapped by this function.</span>
<span class="sd">If we have lots of incident energies, this splits up the calculation using the multiprocessing module.</span>
<span class="sd">May still need to tweak the &#39;NE&#39; and &#39;nprocesses&#39; variables for best performance.</span>
<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="blockwise"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.blockwise">[docs]</a><span class="k">def</span> <span class="nf">blockwise</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">E</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
            <span class="c"># turn E into a column vector</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">NE</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">NE</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span> <span class="c"># faster to run directly</span>
                <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>
                <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

                <span class="k">def</span> <span class="nf">enqueue_result</span><span class="p">(</span><span class="n">elist</span><span class="p">,</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
                    <span class="c"># perform the calculation, put result in the queue</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elist</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="n">Slice</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="p">)</span>
                    <span class="k">return</span>

                <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">nprocesses</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c"># number of processes to spawn</span>
                <span class="c"># how many energies does each process calculate?</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">NE</span><span class="o">+</span><span class="mf">0.</span><span class="p">)</span> <span class="o">/</span> <span class="n">nprocesses</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocesses</span><span class="p">):</span> <span class="c"># start the calculations</span>
                    <span class="n">Slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">enqueue_result</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">Slice</span><span class="p">],</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">queue</span><span class="p">))</span>
                    <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprocesses</span><span class="p">):</span> <span class="c"># collect results as they finish</span>
                    <span class="n">Slice</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span> <span class="n">vals</span> <span class="p">)</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">NE</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">Slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                <span class="c"># allow child processes to exit:</span>
                <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span> <span class="n">job</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapped</span>


<span class="c">#### Single-level Breit-Wigner ###</span></div>
<div class="viewcode-block" id="SLBWcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.SLBWcrossSection">[docs]</a><span class="k">class</span> <span class="nc">SLBWcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    given a resonance region in SLBW format,</span>
<span class="sd">    create a class with all data required to reconstruct</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SLBWcrossSection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortLandJ</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;From </span><span class="si">%f</span><span class="s"> to </span><span class="si">%f</span><span class="s"> eV, reconstructing using Single-level Breit-Wigner&quot;</span> <span class="o">%</span> 
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">))</span>
    
    <span class="nd">@blockwise</span>
<div class="viewcode-block" id="SLBWcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.SLBWcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="n">captureSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="c"># for calculating phi, always use tabulated scattering radius:</span>
        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rhohat</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s">&#39;Js&#39;</span><span class="p">]:</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="s">&#39;gfact&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">J</span><span class="p">[</span><span class="s">&#39;channelSpins&#39;</span><span class="p">]:</span>
                    <span class="n">dE</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;shiftFactor&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">S</span><span class="p">)))</span>
                    <span class="n">totalWidth</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]</span>
                    <span class="n">denominator</span> <span class="o">=</span> <span class="n">dE</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">totalWidth</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span>
                    <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span> <span class="n">P</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span> <span class="n">P</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> 
                        <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">totalWidth</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span> 
                        <span class="o">/</span> <span class="n">denominator</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c"># numpy.sum(..., axis=1) returns row vector, so also convert first term to row vector:</span>
            <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="c"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">captureSum</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="p">(</span><span class="n">capture</span><span class="p">,</span><span class="n">elastic</span><span class="p">,</span><span class="n">fission</span><span class="p">):</span>
            <span class="n">reaction</span><span class="p">[</span> <span class="n">reaction</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="c">#### Multi-level Breit-Wigner ###</span></div></div>
<div class="viewcode-block" id="MLBWcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.MLBWcrossSection">[docs]</a><span class="k">class</span> <span class="nc">MLBWcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    given a resonance region in MLBW format,</span>
<span class="sd">    create a class with all data required to reconstruct</span>
<span class="sd">    </span>
<span class="sd">    only the elastic channel differs from SLBW</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MLBWcrossSection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortLandJ</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;From </span><span class="si">%f</span><span class="s"> to </span><span class="si">%f</span><span class="s"> eV, reconstructing using Multi-level Breit-Wigner&quot;</span> <span class="o">%</span> 
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">))</span>
    
    <span class="nd">@blockwise</span>
<div class="viewcode-block" id="MLBWcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.MLBWcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="n">captureSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="c"># for phi:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
            <span class="n">rhohat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">E</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))[:,</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rhohat</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s">&#39;Js&#39;</span><span class="p">]:</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="s">&#39;gfact&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">J</span><span class="p">[</span><span class="s">&#39;channelSpins&#39;</span><span class="p">]:</span>
                    <span class="n">dE</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;shiftFactor&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">S</span><span class="p">)))</span>
                    <span class="n">totalWidth</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]</span>
                    <span class="n">denominator</span> <span class="o">=</span> <span class="n">dE</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">totalWidth</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span>
                    <span class="n">commonFactor</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">denominator</span>
                    <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">commonFactor</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">commonFactor</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                    <span class="c"># simple elastic method, Eq D.19 - D.21 in ENDF 102. This has numerical issues, however:</span>
                    <span class="c"># U_nn = numpy.exp(-2*1j*phi[:,0]) * (1 + numpy.sum( 1j*P*spin[&#39;neutronWidth&#39;] /</span>
                    <span class="c">#     (spin[&#39;energy&#39;]-E-1j*totalWidth/2) , axis=1))</span>
                    <span class="c"># elasticSum += gfactor * abs( (1-U_nn)**2 )</span>

                    <span class="c"># Instead of the above, use the following from RECENT:</span>
                    <span class="n">elasticTerm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">totalWidth</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">commonFactor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                    <span class="n">elasticTerm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">dE</span> <span class="o">*</span> <span class="n">commonFactor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                    <span class="n">sin2ps</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">sinps2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                    <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="p">((</span><span class="n">sinps2</span><span class="o">-</span><span class="n">elasticTerm1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">sin2ps</span><span class="o">+</span><span class="n">elasticTerm2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">True</span><span class="p">:</span> <span class="c">#addMissingGfactor:</span>
                <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        
        <span class="c"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">captureSum</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="p">(</span><span class="n">capture</span><span class="p">,</span><span class="n">elastic</span><span class="p">,</span><span class="n">fission</span><span class="p">):</span>
            <span class="n">reaction</span><span class="p">[</span> <span class="n">reaction</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">}</span>


<span class="c">###### Reich_Moore and R-Matrix Limited ######</span>

<span class="c"># some helper functions:</span>
</div></div>
<div class="viewcode-block" id="getRI_SI"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.getRI_SI">[docs]</a><span class="k">def</span> <span class="nf">getRI_SI</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">Eres</span><span class="p">,</span> <span class="n">captureWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Both versions of Reich_Moore formalisms (LRF=3 and 7) rely on building matrices R and S,</span>
<span class="sd">    which represent symmetric and anti-symmetric scattering respectively</span>
<span class="sd">    </span>
<span class="sd">    matrix elements R[i,j] and S[i,j] =</span>
<span class="sd">    </span>
<span class="sd">    (summed over resonances) partialWidth[i]*partialWidth[j] * coefficient/(dE**2+captureWidth**2),</span>
<span class="sd">    </span>
<span class="sd">    for the ith/jth open channel. For S, the coefficient is &#39;dE&#39;, for R &#39;captureWidth&#39;</span>
<span class="sd">    and partialWidth[i] = widths[i] * penetrabilities[i]</span>
<span class="sd">        ( widths[i] is a row vector of resonance widths, and penetrabilities[i] is a column vector </span>
<span class="sd">        of the penetrability for each incident energy )</span>
<span class="sd">    </span>
<span class="sd">    Then, invert to find RI and SI such that (I+R+jS)*(I+RI+jSI) = I</span>
<span class="sd">    where I is the identity matrix, and j = sqrt(-1)</span>
<span class="sd">    </span>
<span class="sd">    incident energy dependence appears in both in E and the penetrabilities</span>
<span class="sd">    </span>
<span class="sd">    additional documentation from RECENT::</span>
<span class="sd">    </span>
<span class="sd">      THE CROSS SECTIONS ARE DEFINED TO BE,</span>
<span class="sd"> </span>
<span class="sd">      TOTAL        =2*GJ*REAL(I - U(N,N))</span>
<span class="sd">      ABSORPTION   =4*GJ*(REAL(RHO(N,N)) - RHO(N,N)**2)</span>
<span class="sd">                   =  GJ*(I - U(N,N)**2)</span>
<span class="sd">      ELASTIC      =  GJ*(I - U(N,N))**2</span>
<span class="sd">      FISSION      =4*GJ*(SUM OVER C)(RHO(N,C)**2)</span>
<span class="sd">      CAPTURE      = ABSORPTION - FISSION</span>
<span class="sd"> </span>
<span class="sd">      WHICH ARE COMPLETELY DEFINED IN TERMS OF U(N,N) AND RHO(N,C),</span>
<span class="sd"> </span>
<span class="sd">      RHO(N,C)     =I - INVERSE(I - K)</span>
<span class="sd">      U(N,N)       =EXP(-I*2*PS)*(2*INVERSE(I - K) - I)</span>
<span class="sd">                   =(COS(2*PS) - I*SIN(2*PS))*(2*INVERSE(I - K) - I)</span>
<span class="sd">                   =(COS(2*PS) - I*SIN(2*PS))*(1 - 2*RHO(N,N))</span>
<span class="sd"> </span>
<span class="sd">                   =COS(2*PS)*(I-2*REAL(RHO)) - I*2*SIN(2*PS)*IM(RHO)</span>
<span class="sd"> </span>
<span class="sd">      ... (cmattoon: cutting some of the documentation here) ...</span>
<span class="sd">      </span>
<span class="sd">      (I - K)      = (R + I) - I*S</span>
<span class="sd"> </span>
<span class="sd">      R            = SQRT(GAM(C)/2*GAM(C*)/2)*(GAM/2)/DEN</span>
<span class="sd">      S            = SQRT(GAM(C)/2*GAM(C*)/2)*(ER-E)/DEN</span>
<span class="sd">      GAM(R)       = ELIMINATED RADIATIVE WIDTH</span>
<span class="sd">      GAM(C)       = PARTIAL WIDE FOR CHANNEL C FOR A RESONANCE</span>
<span class="sd">      DEN          = ((ER - E)**2 + (GAM/2)**2)</span>
<span class="sd"> </span>
<span class="sd">      SUMMED OVER RESONANCES FOR EACH (L,J) SEQUENCE.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>         <span class="c"># number of energies</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span>   <span class="c"># dimension of matrix at each energy</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># use wrapped c version if available:</span>
        <span class="kn">import</span> <span class="nn">getScatteringMatrices</span>
        <span class="c"># convert any constant width/penetrability data to array w/correct dimensions:</span>
        <span class="n">nRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Eres</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">nRes</span><span class="p">:</span>
                <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">nRes</span><span class="p">))</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">penetrabilities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">NE</span><span class="p">:</span>
                <span class="n">penetrabilities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">penetrabilities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">R</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">getScatteringMatrices</span><span class="o">.</span><span class="n">getScatteringMatrices</span><span class="p">(</span> <span class="n">E</span><span class="p">,</span> <span class="n">Eres</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">captureWidth</span><span class="p">,</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">penetrabilities</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="c"># can&#39;t import c version, so use numpy (memory-intensive)</span>
        <span class="c"># define some common factors.</span>
        <span class="c"># These are all 2d arrays with len(E) rows, len(Eres) columns:</span>
        <span class="n">dE</span> <span class="o">=</span> <span class="n">Eres</span> <span class="o">-</span> <span class="n">E</span>
        <span class="n">DEN</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">dE</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">captureWidth</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">captOverDEN</span> <span class="o">=</span> <span class="n">captureWidth</span><span class="o">*</span><span class="n">DEN</span>
        <span class="n">dEoverDEN</span> <span class="o">=</span> <span class="n">dE</span><span class="o">*</span><span class="n">DEN</span>
        <span class="k">del</span> <span class="n">dE</span><span class="p">,</span> <span class="n">DEN</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">width_ij</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">widths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">p_ij</span> <span class="o">=</span> <span class="n">penetrabilities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">penetrabilities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">R</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_ij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">width_ij</span> <span class="o">*</span> <span class="n">captOverDEN</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">S</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_ij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">width_ij</span> <span class="o">*</span> <span class="n">dEoverDEN</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c"># symmetrize:</span>
                <span class="n">R</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="n">S</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">captOverDEN</span><span class="p">,</span> <span class="n">dEoverDEN</span>

    <span class="c"># now we have complex matrix I+R+j*S</span>
    <span class="c"># invert to find RI and SI such that (I+R+j*S) * (I+RI+j*SI) = I</span>
    <span class="c"># see comments for subroutine FROBNS3 in recent.f:</span>
    <span class="k">if</span> <span class="n">dim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="c"># only have neutron width (and &#39;eliminated&#39; capture width).</span>
        <span class="c"># Can obtain quicker solution by manually inverting:</span>
        <span class="n">R</span><span class="p">,</span><span class="n">S</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span><span class="n">S</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>   <span class="c"># cut extra dimensions</span>
        <span class="c"># invert:</span>
        <span class="n">DET</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">S</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">SI</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="o">/</span><span class="n">DET</span>
        <span class="n">RI</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">R</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">DET</span>
        <span class="k">return</span> <span class="n">RI</span><span class="p">,</span><span class="n">SI</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># have competition and/or fission, must invert matrices:</span>
        <span class="k">def</span> <span class="nf">dotproduct</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="c"># helper function: dotproduct(A,B,C) == numpy.dot(A, numpy.dot(B,C))</span>
            <span class="k">def</span> <span class="nf">quickdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
                <span class="c"># take dot product of two Nx(MxM) arrays (containing MxM matrices):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                        <span class="n">result</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">a</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[:,:,</span><span class="n">j</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span> <span class="n">quickdot</span><span class="p">,</span> <span class="n">args</span> <span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">vectorInv</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="c"># invert all MxM matrices in Nx(MxM) array</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">arrinv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">det</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="k">return</span> <span class="n">arrinv</span>
            <span class="k">elif</span> <span class="n">dim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">arrinv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">det</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="o">+</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="k">return</span> <span class="n">arrinv</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
                <span class="n">NE</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NE</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">result</span>
        
        <span class="n">identity</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">NE</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">identity</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="n">invRplusI</span> <span class="o">=</span> <span class="n">vectorInv</span><span class="p">(</span> <span class="n">R</span> <span class="o">+</span> <span class="n">identity</span> <span class="p">)</span>
        <span class="n">SRS</span> <span class="o">=</span> <span class="n">dotproduct</span><span class="p">(</span> <span class="n">S</span><span class="p">,</span> <span class="n">invRplusI</span><span class="p">,</span> <span class="n">S</span> <span class="p">)</span>
        <span class="n">RI</span> <span class="o">=</span> <span class="n">dotproduct</span><span class="p">(</span> <span class="o">-</span><span class="n">vectorInv</span><span class="p">(</span> <span class="n">R</span><span class="o">+</span><span class="n">identity</span> <span class="o">+</span> <span class="n">SRS</span> <span class="p">),</span> <span class="n">R</span><span class="o">+</span><span class="n">SRS</span> <span class="p">)</span>
        <span class="n">SI</span> <span class="o">=</span> <span class="n">dotproduct</span><span class="p">(</span> <span class="o">-</span><span class="n">invRplusI</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">RI</span><span class="o">+</span><span class="n">identity</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">RI</span><span class="p">,</span> <span class="n">SI</span>


<span class="c">#### Reich_Moore ####</span></div>
<div class="viewcode-block" id="RMcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RMcrossSection">[docs]</a><span class="k">class</span> <span class="nc">RMcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    simplified Reich_Moore (LRF=3 in ENDF)</span>
<span class="sd">    More complex than Breit-Wigner approximations, but we can still use same __init__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RMcrossSection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortLandJ</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;From </span><span class="si">%f</span><span class="s"> to </span><span class="si">%f</span><span class="s"> eV, reconstructing using Reich_Moore (LRF=3)&quot;</span> <span class="o">%</span> 
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">))</span>

    <span class="nd">@blockwise</span>
<div class="viewcode-block" id="RMcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RMcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">absorbtionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">haveFission</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="s">&#39;eV&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
        <span class="c"># for calculating phi, always use tabulated scattering radius:</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">l</span><span class="p">)</span>
            <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rhohat</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span> <span class="p">)</span>

            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s">&#39;Js&#39;</span><span class="p">]:</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="s">&#39;gfact&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">J</span><span class="p">[</span><span class="s">&#39;channelSpins&#39;</span><span class="p">]:</span>
                    <span class="n">captureWidth</span> <span class="o">=</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span>
                    <span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">penetrabilities</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">penetrabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">haveFission</span><span class="p">:</span>
                        <span class="n">fissWidthA</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>
                        <span class="n">fissWidthB</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s">&#39;fissionWidthB&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>
                        <span class="n">fissWidthA</span><span class="p">[</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">fissWidthB</span><span class="p">[</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;fissionWidthB&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">widths</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fissWidthA</span><span class="p">,</span> <span class="n">fissWidthB</span><span class="p">]</span>
                        <span class="n">penetrabilities</span> <span class="o">+=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])]</span>
                        
                        <span class="n">RI</span><span class="p">,</span><span class="n">SI</span> <span class="o">=</span> <span class="n">getRI_SI</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">],</span> <span class="n">captureWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">)</span>
                        
                        <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                                <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">absorbtionSum</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">gfactor</span> <span class="o">*</span> <span class="p">(</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">SI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">fissionSum</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">*</span><span class="n">gfactor</span> <span class="o">*</span> <span class="p">(</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">RI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">SI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">SI</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    
                    <span class="k">else</span><span class="p">:</span> <span class="c"># faster method when we don&#39;t have fission:</span>
                        <span class="n">RI</span><span class="p">,</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">getRI_SI</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">spin</span><span class="p">[</span><span class="s">&#39;energy&#39;</span><span class="p">],</span> <span class="n">captureWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">)</span>
                        <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">RI</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
                                <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">absorbtionSum</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">gfactor</span> <span class="o">*</span> <span class="p">(</span><span class="n">RI</span> <span class="o">+</span> <span class="n">RI</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">SI</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">True</span><span class="p">:</span> <span class="c">#addMissingGfactor:</span>
                <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">absorbtion</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">absorbtionSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">absorbtion</span> <span class="o">-</span> <span class="n">fission</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">absorbtion</span>

        <span class="k">return</span> <span class="p">{</span><span class="s">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">}</span>


<span class="c">#### R-Matrix Limited ####</span></div></div>
<div class="viewcode-block" id="RMatrixLimitedcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RMatrixLimitedcrossSection">[docs]</a><span class="k">class</span> <span class="nc">RMatrixLimitedcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    extended Reich_Moore (LRF=7 in ENDF)</span>
<span class="sd">    Here, resonances are sorted primarily by J: within each &#39;spin group&#39;, total J is conserved</span>
<span class="sd">    One or more competitive channels may be used in this case.</span>
<span class="sd">    Also, each resonance may have contributions from multiple l-waves</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RMatrixLimitedcrossSection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">sectionIndex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;From </span><span class="si">%f</span><span class="s"> to </span><span class="si">%f</span><span class="s"> eV, reconstructing using R-Matrix Limited (LRF=7)&quot;</span> <span class="o">%</span> 
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">))</span>
        
        <span class="c"># for RML, need info on residual nuclei from each channel:</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span><span class="p">:</span>
            <span class="n">reaction</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
            <span class="c"># elastic, capture or competitive?</span>
            <span class="k">if</span> <span class="n">reaction</span> <span class="o">==</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="s">&#39;capture&#39;</span><span class="p">):</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="s">&#39;capture&#39;</span>
            <span class="k">elif</span> <span class="n">reaction</span> <span class="o">==</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="s">&#39;elastic&#39;</span><span class="p">):</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="s">&#39;elastic&#39;</span>
            <span class="k">elif</span> <span class="s">&#39;fission&#39;</span> <span class="ow">in</span> <span class="n">ch</span><span class="o">.</span><span class="n">channel</span><span class="p">:</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">channel</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="s">&#39;competitive&#39;</span>
            
            <span class="n">Q</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">Qvalue</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Q</span><span class="p">:</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">reaction</span><span class="o">.</span><span class="n">getQ</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
                <span class="c"># adjust Q value for residual in excited state:</span>
                <span class="k">for</span> <span class="n">particle</span> <span class="ow">in</span> <span class="n">reaction</span><span class="o">.</span><span class="n">outputChannel</span><span class="o">.</span><span class="n">particles</span><span class="p">:</span>
                    <span class="n">Q</span> <span class="o">-=</span> <span class="n">particle</span><span class="o">.</span><span class="n">getLevelAsFloat</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
            <span class="n">Q</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetToNeutronMassRatio</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetToNeutronMassRatio</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">particles</span> <span class="o">=</span> <span class="n">reaction</span><span class="o">.</span><span class="n">outputChannel</span><span class="o">.</span><span class="n">particles</span>
            <span class="n">ch</span><span class="o">.</span><span class="n">reactionInfo</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#39;Q&#39;</span><span class="p">:</span><span class="n">Q</span><span class="p">,</span> <span class="s">&#39;particles&#39;</span><span class="p">:</span> <span class="n">particles</span> <span class="p">}</span>
        
        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">sg</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s">&#39;energy&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">)</span> <span class="p">)</span>
            
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s">&#39;energy&#39;</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">channelName</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; width&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">openChannel</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">channel</span><span class="o">==</span><span class="n">channelName</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">openChannel</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;Could not find unique openChannel named &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">channelName</span><span class="p">)</span>
                <span class="n">column</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">openChannel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span>
        
        <span class="c"># for energy grid generation:</span>
        <span class="n">energies</span><span class="p">,</span> <span class="n">totalWidths</span> <span class="o">=</span> <span class="p">[],[]</span>
        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s">&#39;energy&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">col</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;eV&#39;</span> <span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span>
                    <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s">&#39;energy&#39;</span><span class="p">]</span>
            <span class="n">totalWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">widths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">zipped</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span><span class="n">totalWidths</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zipped</span><span class="p">)</span>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.rho"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RMatrixLimitedcrossSection.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="c"># get the channel radius rho for each channel:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span> 
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">channels</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="RMatrixLimitedcrossSection.k_competitive"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RMatrixLimitedcrossSection.k_competitive">[docs]</a>    <span class="k">def</span> <span class="nf">k_competitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate k for any 2-body output channel. Note that if pA and pB are target and neutron,</span>
<span class="sd">        this reduces to self.k(E) as defined above in the resonanceReconstructionBaseClass &quot;&quot;&quot;</span>
        <span class="n">pA_mass</span><span class="p">,</span> <span class="n">pB_mass</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">particle</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pA</span><span class="p">,</span><span class="n">pB</span><span class="p">]</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectile</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span>
        <span class="c"># sqrt(2*neutronMass)/hbar == 2.196807 (eV*barn)**-1/2. Thus for energy in eV, k is in b**-1/2</span>
        <span class="k">return</span> <span class="mf">2.196807122623e-3</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">pB_mass</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pA_mass</span> <span class="o">/</span> <span class="p">(</span><span class="n">pB_mass</span> <span class="o">+</span> <span class="n">mn</span><span class="p">)</span> <span class="o">/</span>
                <span class="p">(</span><span class="n">pB_mass</span> <span class="o">+</span> <span class="n">pA_mass</span><span class="p">)</span> <span class="o">/</span> <span class="n">mn</span> <span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="RMatrixLimitedcrossSection.eta"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RMatrixLimitedcrossSection.eta">[docs]</a>    <span class="k">def</span> <span class="nf">eta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;for competitive channels with 2 charged particles,</span>
<span class="sd">        parameter eta used to find penetrability. eq D.79 in ENDF manual:&#39;&#39;&#39;</span>
        <span class="n">pA_z</span><span class="p">,</span> <span class="n">pB_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">particle</span><span class="o">.</span><span class="n">getZ_A_SuffixAndZA</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pA_z</span> <span class="o">*</span> <span class="n">pB_z</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pA_mass</span><span class="p">,</span> <span class="n">pB_mass</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">particle</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pA</span><span class="p">,</span><span class="n">pB</span><span class="p">]</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectile</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span>
        <span class="n">eSq_over_hbarSq</span> <span class="o">=</span> <span class="mf">3.4746085579272e-1</span>    <span class="c"># units?</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="p">(</span><span class="n">eSq_over_hbarSq</span> <span class="o">*</span> <span class="n">pA_z</span> <span class="o">*</span> <span class="n">pB_z</span> <span class="o">*</span> <span class="p">(</span><span class="n">pA_mass</span><span class="o">/</span><span class="n">mn</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pB_mass</span><span class="o">/</span><span class="p">(</span><span class="n">pB_mass</span><span class="o">+</span><span class="n">pA_mass</span><span class="p">))</span> 
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">eta</span>
    </div>
<div class="viewcode-block" id="RMatrixLimitedcrossSection.coulombPenetrationFactor"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RMatrixLimitedcrossSection.coulombPenetrationFactor">[docs]</a>    <span class="k">def</span> <span class="nf">coulombPenetrationFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; for competitive channels with 2 charged particles, </span>
<span class="sd">        calculate coulomb wavefunctions and penetrability.</span>
<span class="sd">        Here we use an external subroutine &#39;coulfg2&#39; from Thompson et al, converted to c and wrapped &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">getCoulombWavefunctions</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">rho</span><span class="o">&lt;</span><span class="mf">0.02</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;      WARNING: small rho values encountered, may need modified coulomb penetrability!&quot;</span><span class="p">)</span>
        <span class="n">penetrability</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">rho</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
        <span class="n">F</span><span class="p">,</span><span class="n">G</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">getCoulombWavefunctions</span><span class="p">(</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">L</span> <span class="p">)</span>
        <span class="n">penetrability</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">/</span> <span class="p">(</span><span class="n">F</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">G</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">penetrability</span>
    </div>
    <span class="nd">@blockwise</span>
<div class="viewcode-block" id="RMatrixLimitedcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.RMatrixLimitedcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        similar to Reich_Moore (LRF=3). Refer to comments there, and in</span>
<span class="sd">        subroutine SIGRM2 in recent.f</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">absorbtionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nCompetitive</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s">&#39;competitive&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">competitiveSum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,]</span> <span class="o">*</span> <span class="n">nCompetitive</span>
        <span class="n">haveFission</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="s">&#39;fission&#39;</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">channel</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="o">.</span><span class="n">value</span>
            <span class="n">gfact</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">penetrabilities</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">phis</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c"># phi is l-dependant</span>
            <span class="n">qvalues</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s">&#39;energy&#39;</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">chanWidths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">chan</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;eV&#39;</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">channelName</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; width&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">parentChannel</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">channel</span> <span class="o">==</span> <span class="n">channelName</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s">&#39;capture&#39;</span><span class="p">:</span>
                    <span class="n">captureWidth</span> <span class="o">=</span> <span class="n">chanWidths</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="k">continue</span>
                <span class="c"># else:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">chan</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]</span>
                <span class="n">pA</span><span class="p">,</span><span class="n">pB</span> <span class="o">=</span> <span class="n">parentChannel</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s">&#39;particles&#39;</span><span class="p">]</span>
                <span class="n">Qvalue</span> <span class="o">=</span> <span class="n">parentChannel</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s">&#39;Q&#39;</span><span class="p">]</span>
                <span class="n">qvalues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Qvalue</span> <span class="p">)</span>
                
                <span class="c"># channel radius:</span>
                <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span> <span class="n">E</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>
                    <span class="k">elif</span> <span class="n">chan</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;effectiveRadius&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="n">chan</span><span class="p">[</span><span class="s">&#39;effectiveRadius&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>
                
                <span class="c"># for calculating phi, always use tabulated (not calculated) scattering radius:</span>
                <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;effectiveRadius&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">rhohat</span> <span class="o">=</span> <span class="n">chan</span><span class="p">[</span><span class="s">&#39;effectiveRadius&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                <span class="n">phinow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rhohat</span><span class="p">)</span>
                <span class="n">phinow</span><span class="p">[</span> <span class="n">phinow</span><span class="o">/</span><span class="n">rhohat</span> <span class="o">&lt;</span> <span class="mf">1e-6</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># see subroutine &#39;facphi&#39; in RECENT</span>
                <span class="n">phis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">phinow</span> <span class="p">)</span>
                
                <span class="c"># penetrability:</span>
                <span class="n">Ex1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span><span class="o">+</span><span class="n">Qvalue</span>     <span class="c"># evaluated at resonances</span>
                <span class="n">Ex2</span> <span class="o">=</span> <span class="n">E</span><span class="o">+</span><span class="n">Qvalue</span><span class="p">;</span> <span class="n">Ex2</span><span class="p">[</span><span class="n">Ex2</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># evaluated at each incident energy</span>
                <span class="n">eta1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ex1</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                <span class="n">eta2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ex2</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">eta1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c"># channel has two charged particles, need Coulomb penetrability:</span>
                    <span class="n">penetrabilityAtResonances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Ex1</span><span class="p">)),</span> <span class="n">eta1</span><span class="p">)</span>
                    <span class="n">penetrabilityAtEin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">(</span><span class="n">Ex2</span><span class="p">),</span> <span class="n">eta2</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># no coulomb contribution:</span>
                    <span class="n">penetrabilityAtResonances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Ex1</span><span class="p">)))</span>
                    <span class="n">penetrabilityAtEin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="n">Ex2</span><span class="p">))</span> <span class="p">)</span>
                
                <span class="n">reducedWidths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chanWidths</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">penetrabilityAtResonances</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">reducedWidths</span><span class="p">[</span> <span class="n">chanWidths</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">reducedWidths</span> <span class="p">)</span>
                <span class="n">penetrabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">penetrabilityAtEin</span> <span class="p">)</span>
            
            <span class="c"># are there any threshold reactions (negative Q-values)?</span>
            <span class="c"># If so, we must break up the calculation above/below each threshold</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span> <span class="p">[</span><span class="n">q</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qvalues</span><span class="p">]</span> <span class="p">):</span>
                <span class="c"># sanity check: channels should be sorted by increasing threshold</span>
                <span class="k">assert</span> <span class="n">qvalues</span><span class="o">==</span><span class="nb">sorted</span><span class="p">(</span><span class="n">qvalues</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                
                <span class="n">RI</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)))</span>
                <span class="n">SI</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">RI</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
                
                <span class="c"># get energy index for each threshold:</span>
                <span class="kn">import</span> <span class="nn">bisect</span>
                <span class="n">thresholds</span> <span class="o">=</span> <span class="p">([</span><span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">E</span><span class="o">+</span><span class="n">Q</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">Q</span> <span class="ow">in</span> <span class="n">qvalues</span><span class="p">])</span>
                <span class="n">thresholds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">threshSet</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">thresholds</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">threshSet</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="n">threshSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">high</span> <span class="o">=</span> <span class="n">threshSet</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">nOpen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="p">[</span><span class="n">th</span> <span class="k">for</span> <span class="n">th</span> <span class="ow">in</span> <span class="n">thresholds</span> <span class="k">if</span> <span class="n">th</span><span class="o">-</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                    <span class="n">RI_now</span><span class="p">,</span> <span class="n">SI_now</span> <span class="o">=</span> <span class="n">getRI_SI</span><span class="p">(</span> <span class="n">E</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">],</span> <span class="n">sg</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">captureWidth</span><span class="p">,</span> 
                            <span class="n">widths</span><span class="p">[:</span><span class="n">nOpen</span><span class="p">],</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">penetrabilities</span><span class="p">[:</span><span class="n">nOpen</span><span class="p">]]</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">nOpen</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>  <span class="c"># numpy insists on same number of dimensions for copy:</span>
                        <span class="n">RI_now</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">SI_now</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">RI_now</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                    
                    <span class="n">RI</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">]</span> <span class="o">=</span> <span class="n">RI_now</span>
                    <span class="n">SI</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">]</span> <span class="o">=</span> <span class="n">SI_now</span>
            
            <span class="k">else</span><span class="p">:</span>   <span class="c"># no threshold reactions</span>
                <span class="n">RI</span><span class="p">,</span><span class="n">SI</span> <span class="o">=</span> <span class="n">getRI_SI</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">sg</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">captureWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">)</span>
            
            <span class="c"># reconstruct:</span>
            <span class="n">chanIds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="s">&#39;energy&#39;</span> <span class="ow">or</span> <span class="n">col</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s">&#39;capture&#39;</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">thisChannel</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span> <span class="k">if</span> 
                        <span class="n">ch</span><span class="o">.</span><span class="n">channel</span><span class="o">==</span><span class="n">col</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; width&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">chanIds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">thisChannel</span> <span class="p">)</span> <span class="p">)</span>
            <span class="n">chanIds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">chanIds</span> <span class="p">)</span>
            <span class="n">elasID</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s">&#39;elastic&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c"># should be &#39;1&#39;</span>
            <span class="n">competitiveIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s">&#39;competitive&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s">&#39;capture&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>    <span class="c"># &#39;eliminated&#39; channel in Reich_Moore</span>
                <span class="c"># which matrix elements correspond to this channel?</span>
                <span class="n">thisChanIds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">chanIds</span><span class="o">==</span><span class="n">chan</span><span class="o">.</span><span class="n">index</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">)</span> <span class="o">==</span> <span class="n">id2</span><span class="o">-</span><span class="n">id1</span>
                <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s">&#39;elastic&#39;</span><span class="p">:</span>
                    <span class="n">elas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">absorb</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c"># diagonal component</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">id1</span><span class="p">,</span><span class="n">id2</span><span class="p">):</span>
                        <span class="n">phi</span> <span class="o">=</span> <span class="n">phis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># convert to row vector</span>
                        <span class="n">sinsqr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                        <span class="n">sincos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
                        <span class="n">elas</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">sinsqr</span> <span class="o">*</span> <span class="p">(</span><span class="n">sinsqr</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">RI</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">sincos</span> <span class="o">*</span> <span class="p">(</span><span class="n">sincos</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="p">)</span>
                        <span class="n">absorb</span> <span class="o">+=</span> <span class="o">-</span><span class="n">RI</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
                    <span class="c"># add cross-terms:</span>
                    <span class="n">elas</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">RI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">SI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">absorb</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">RI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">SI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> 
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">elas</span>
                    <span class="n">absorbtionSum</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">absorb</span>
                
                <span class="k">else</span><span class="p">:</span> <span class="c"># competitive or fission:</span>
                    <span class="c"># sum of cross-terms between this channel and elastic:</span>
                    <span class="k">if</span> <span class="s">&#39;fission&#39;</span> <span class="ow">in</span> <span class="n">chan</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
                        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;      WARNING: haven&#39;t dealt with R-Matrix fission yet... proceed with caution!&quot;</span><span class="p">)</span>
                    <span class="n">elasticIds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">chanIds</span><span class="o">==</span><span class="n">elasID</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">el1</span><span class="p">,</span> <span class="n">el2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">elasticIds</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">elasticIds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">SI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">el1</span><span class="p">:</span><span class="n">el2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">RI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">el1</span><span class="p">:</span><span class="n">el2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c"># may have more than one competitive: add to correct channel</span>
                    <span class="n">competitiveSum</span><span class="p">[</span> <span class="n">competitiveIDs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">chan</span><span class="o">.</span><span class="n">index</span> <span class="p">)</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">comp</span>
            
        <span class="c"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">absorbtion</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">absorbtionSum</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">absorbtion</span>
        <span class="n">competitive</span> <span class="o">=</span> <span class="p">[</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">comp</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">competitiveSum</span> <span class="p">]</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">absorbtion</span> <span class="o">-</span> <span class="n">fission</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">competitive</span><span class="p">)</span>
        
        <span class="n">retDict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">}</span>
        <span class="n">competitiveNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span><span class="o">.</span><span class="n">channel</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">openChannels</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s">&#39;competitive&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">competitiveNames</span><span class="p">,</span><span class="n">competitive</span><span class="p">):</span>
            <span class="n">retDict</span><span class="p">[</span> <span class="n">key</span> <span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">retDict</span>


<span class="c">##### unresolved resonance region. Only one formalism here: #####</span></div></div>
<div class="viewcode-block" id="URRcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.URRcrossSection">[docs]</a><span class="k">class</span> <span class="nc">URRcrossSection</span><span class="p">(</span><span class="n">resonanceReconstructionBaseClass</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionSuite</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">URRcrossSection</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        
        <span class="c"># energy boundaries for this region:</span>
        <span class="n">urr</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">URR</span> <span class="o">=</span> <span class="n">urr</span><span class="o">.</span><span class="n">nativeData</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">=</span> <span class="n">urr</span><span class="o">.</span><span class="n">lowerBound</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">=</span> <span class="n">urr</span><span class="o">.</span><span class="n">upperBound</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Unresolved from </span><span class="si">%f</span><span class="s"> to </span><span class="si">%f</span><span class="s"> eV&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">))</span>
    
<div class="viewcode-block" id="URRcrossSection.rho"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.URRcrossSection.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="c"># always calculate channel radius for unresolved:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s">&#39;amu&#39;</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>
    </div>
<div class="viewcode-block" id="URRcrossSection.getFluctuationIntegrals"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.URRcrossSection.getFluctuationIntegrals">[docs]</a>    <span class="k">def</span> <span class="nf">getFluctuationIntegrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">DOF</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; from subroutine GNRL3 in RECENT. If possible, this will be replaced</span>
<span class="sd">        with more basic approach (rather than using lookup table)... not finding </span>
<span class="sd">        appropriate equations right now &quot;&quot;&quot;</span>
        <span class="n">XX</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.0013465e-03</span><span class="p">,</span><span class="mf">1.3219203e-02</span><span class="p">,</span><span class="mf">1.0004488e-03</span><span class="p">,</span><span class="mf">1.3219203e-02</span><span class="p">,</span><span class="mf">1.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">7.8592886e-02</span><span class="p">,</span><span class="mf">7.2349624e-02</span><span class="p">,</span><span class="mf">2.6197629e-02</span><span class="p">,</span><span class="mf">7.2349624e-02</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.3282415e-01</span><span class="p">,</span><span class="mf">1.9089473e-01</span><span class="p">,</span><span class="mf">1.4427472e-01</span><span class="p">,</span><span class="mf">1.9089473e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.3345267e+00</span><span class="p">,</span><span class="mf">3.9528842e-01</span><span class="p">,</span><span class="mf">4.4484223e-01</span><span class="p">,</span><span class="mf">3.9528842e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">3.0481846e+00</span><span class="p">,</span><span class="mf">7.4083443e-01</span><span class="p">,</span><span class="mf">1.0160615e+00</span><span class="p">,</span><span class="mf">7.4083443e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">5.8263198e+00</span><span class="p">,</span><span class="mf">1.3498293e+00</span><span class="p">,</span><span class="mf">1.9421066e+00</span><span class="p">,</span><span class="mf">1.3498293e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">9.9452656e+00</span><span class="p">,</span><span class="mf">2.5297983e+00</span><span class="p">,</span><span class="mf">3.3150885e+00</span><span class="p">,</span><span class="mf">2.5297983e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.5782128e+01</span><span class="p">,</span><span class="mf">5.2384894e+00</span><span class="p">,</span><span class="mf">5.2607092e+00</span><span class="p">,</span><span class="mf">5.2384894e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.3996824e+01</span><span class="p">,</span><span class="mf">1.3821772e+01</span><span class="p">,</span><span class="mf">7.9989414e+00</span><span class="p">,</span><span class="mf">1.3821772e+01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">3.6216208e+01</span><span class="p">,</span><span class="mf">7.5647525e+01</span><span class="p">,</span><span class="mf">1.2072069e+01</span><span class="p">,</span><span class="mf">7.5647525e+01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],]</span>
        <span class="n">WW</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.1120413e-01</span><span class="p">,</span><span class="mf">3.3773418e-02</span><span class="p">,</span><span class="mf">3.3376214e-04</span><span class="p">,</span><span class="mf">1.7623788e-03</span><span class="p">,</span><span class="mf">1.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.3546798e-01</span><span class="p">,</span><span class="mf">7.9932171e-02</span><span class="p">,</span><span class="mf">1.8506108e-02</span><span class="p">,</span><span class="mf">2.1517749e-02</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.8440987e-01</span><span class="p">,</span><span class="mf">1.2835937e-01</span><span class="p">,</span><span class="mf">1.2309946e-01</span><span class="p">,</span><span class="mf">8.0979849e-02</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.2419127e-01</span><span class="p">,</span><span class="mf">1.7652616e-01</span><span class="p">,</span><span class="mf">2.9918923e-01</span><span class="p">,</span><span class="mf">1.8797998e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.0967668e-01</span><span class="p">,</span><span class="mf">2.1347043e-01</span><span class="p">,</span><span class="mf">3.3431475e-01</span><span class="p">,</span><span class="mf">3.0156335e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">3.0493789e-02</span><span class="p">,</span><span class="mf">2.1154965e-01</span><span class="p">,</span><span class="mf">1.7766657e-01</span><span class="p">,</span><span class="mf">2.9616091e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.2930874e-03</span><span class="p">,</span><span class="mf">1.3365186e-01</span><span class="p">,</span><span class="mf">4.2695894e-02</span><span class="p">,</span><span class="mf">1.0775649e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.5827047e-04</span><span class="p">,</span><span class="mf">2.2630659e-02</span><span class="p">,</span><span class="mf">4.0760575e-03</span><span class="p">,</span><span class="mf">2.5171914e-03</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.9031965e-06</span><span class="p">,</span><span class="mf">1.6313638e-05</span><span class="p">,</span><span class="mf">1.1766115e-04</span><span class="p">,</span><span class="mf">8.9630388e-10</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.4079206e-08</span><span class="p">,</span><span class="mf">0.0000000e+00</span><span class="p">,</span><span class="mf">5.0989546e-07</span><span class="p">,</span><span class="mf">0.0000000e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],]</span>
        
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">RN</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="c"># We may store non-integer DOF, but we just end up converting to int:</span>
        <span class="n">MUN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">DOF</span><span class="p">[</span><span class="s">&#39;neutronDOF&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">MUN</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">MUN</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span> <span class="n">MUN</span><span class="o">=</span><span class="mi">5</span>
        <span class="n">MUF</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">DOF</span><span class="p">[</span><span class="s">&#39;fissionDOF&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">MUF</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">MUF</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">:</span> <span class="n">MUF</span><span class="o">=</span><span class="mi">5</span>
        <span class="n">MUX</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span> <span class="n">DOF</span><span class="p">[</span><span class="s">&#39;competitiveDOF&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">MUX</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">MUX</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span> <span class="n">MUX</span><span class="o">=</span><span class="mi">5</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">xj</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">MUN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">wj</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">MUN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;competitiveWidth&#39;</span><span class="p">]):</span>
                <span class="n">effj</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">wk</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">effjk</span> <span class="o">=</span> <span class="n">effj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xk</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                        <span class="n">xi</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">wi</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">factor</span> <span class="o">=</span> <span class="n">wi</span><span class="o">*</span><span class="n">wk</span><span class="o">*</span><span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">effjk</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;competitiveWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span>
                        <span class="n">RN</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                        <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
                        <span class="n">RF</span> <span class="o">+=</span> <span class="n">xk</span><span class="o">*</span><span class="n">factor</span>
            <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]):</span>
                <span class="n">effj</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">wk</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">wk</span><span class="o">*</span><span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">effj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xk</span><span class="p">)</span>
                    <span class="n">RN</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                    <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
                    <span class="n">RF</span> <span class="o">+=</span> <span class="n">xk</span><span class="o">*</span><span class="n">factor</span>
            <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;competitiveWidth&#39;</span><span class="p">]):</span>
                <span class="n">effj</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span> <span class="o">+</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">wk</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">wk</span><span class="o">*</span><span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">effj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;competitiveWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xk</span><span class="p">)</span>
                    <span class="n">RN</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                    <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
            <span class="k">else</span><span class="p">:</span>   <span class="c"># only neutron and capture widths:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">])</span>
                <span class="n">RN</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">RN</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span><span class="p">):</span>
            <span class="n">arr</span><span class="p">[</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">RN</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span>
</div>
<div class="viewcode-block" id="URRcrossSection.generateEnergyGrid"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.URRcrossSection.generateEnergyGrid">[docs]</a>    <span class="k">def</span> <span class="nf">generateEnergyGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the energy grid for reconstructing unresolved resonances. Usually this is just the energy grid</span>
<span class="sd">        chosen by the evaluator for storing energy-dependent widths.&quot;&quot;&quot;</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">L_values</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">J_values</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">egrid</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s">&#39;energy&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">egrid</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="n">egrid</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">egrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="ow">or</span> <span class="n">egrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Energy grid in unresolved region doesn&#39;t span stated energy range:&quot;</span> <span class="o">+</span>
                    <span class="s">&quot; (</span><span class="si">%e</span><span class="s"> - </span><span class="si">%e</span><span class="s">) vs (</span><span class="si">%e</span><span class="s"> - </span><span class="si">%e</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">egrid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">egrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">egrid</span>
</div>
<div class="viewcode-block" id="URRcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.fudgeReconstructResonances.URRcrossSection.getCrossSection">[docs]</a>    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interpolateWidths</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get unresolved region cross section for each incident energy in E.</span>
<span class="sd">        By default, calculate on the energy grid supplied and then interpolate the resulting cross section.</span>
<span class="sd">        If interpolateWidths==True, interpolate the average widths during reconstruction instead.&quot;&quot;&quot;</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">()</span> <span class="p">)</span>
        
        <span class="n">captureSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">L_values</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">L</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rhohat</span><span class="p">)</span>
            <span class="c">#S = 0.5*self.shiftFactor(l,rho)</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">J_values</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">value</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="c"># dicts for widths and degrees of freedom.</span>
                <span class="c"># widths may be constant or energy-dependent:</span>
                <span class="c"># convert here from PhysicalQuantity to floats:</span>
                <span class="n">widths</span><span class="p">,</span> <span class="n">DOF</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">wid</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s">&#39;captureWidth&#39;</span><span class="p">,</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">,</span>
                        <span class="s">&#39;competitiveWidth&#39;</span><span class="p">,</span><span class="s">&#39;levelSpacing&#39;</span><span class="p">):</span>
                    <span class="n">widths</span><span class="p">[</span><span class="n">wid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">constantWidths</span><span class="p">,</span> <span class="n">wid</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">wid</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">):</span>
                        <span class="n">widths</span><span class="p">[</span><span class="n">wid</span><span class="p">]</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">wid</span><span class="p">]</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">wid</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s">&#39;eV&#39;</span> <span class="p">)):</span>
                        <span class="k">if</span> <span class="n">interpolateWidths</span><span class="p">:</span>
                            <span class="kn">from</span> <span class="nn">numericalFunctions</span> <span class="kn">import</span> <span class="n">pointwiseXY_C</span>
                            <span class="n">Nenergies</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s">&#39;energy&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">))</span>
                            <span class="n">interp</span> <span class="o">=</span> <span class="n">pointwiseXY_C</span><span class="o">.</span><span class="n">pointwiseXY_C</span><span class="p">(</span>
                                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s">&#39;energy&#39;</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">),</span> <span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="n">wid</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">)],</span>
                                <span class="n">dataForm</span> <span class="o">=</span> <span class="s">&quot;XsAndYs&quot;</span><span class="p">,</span> <span class="n">interpolation</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">interpolation</span> <span class="p">)</span>
                            <span class="n">widthsNow</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">widthsNow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">interp</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">en</span><span class="p">)</span> <span class="p">)</span>
                                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                                    <span class="c"># grrr... data contains invalid log-log or lin-log interpolation</span>
                                    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;WARNING: unresolved resonance widths contain an invalid interpolation!&quot;</span><span class="p">)</span>
                                    <span class="kn">from</span> <span class="nn">fudge.core.math.xData.axes</span> <span class="kn">import</span> <span class="n">linearToken</span>
                                    <span class="n">interp2</span> <span class="o">=</span> <span class="n">pointwiseXY_C</span><span class="o">.</span><span class="n">pointwiseXY_C</span><span class="p">(</span> <span class="n">interp</span><span class="p">,</span> <span class="n">interpolation</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">linearToken</span><span class="p">,</span><span class="n">linearToken</span><span class="p">)</span> <span class="p">)</span>
                                    <span class="n">widthsNow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">interp2</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">en</span><span class="p">)</span> <span class="p">)</span>
                            <span class="n">widths</span><span class="p">[</span><span class="n">wid</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">widthsNow</span> <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">widths</span><span class="p">[</span><span class="n">wid</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">energyDependentWidths</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="n">wid</span><span class="p">,</span><span class="s">&#39;eV&#39;</span><span class="p">)</span> <span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">wid</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
                                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Inconsistent energy arrays encountered in unresolved region!&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;neutronDOF&#39;</span><span class="p">,</span><span class="s">&#39;fissionDOF&#39;</span><span class="p">,</span><span class="s">&#39;competitiveDOF&#39;</span><span class="p">):</span>
                    <span class="n">DOF</span><span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dof</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
                <span class="c"># penetration factor, different from resolved:</span>
                <span class="n">VL</span> <span class="o">=</span> <span class="n">DOF</span><span class="p">[</span><span class="s">&#39;neutronDOF&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span> <span class="o">/</span> <span class="n">rho</span>
                <span class="n">widths</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">VL</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                
                <span class="n">RN</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluctuationIntegrals</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span><span class="n">DOF</span><span class="p">)</span>
                
                <span class="c"># common factor for all reactions:</span>
                <span class="n">comfac</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">gfactor</span><span class="o">*</span><span class="n">widths</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;levelSpacing&#39;</span><span class="p">]</span>
                
                <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">RC</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">comfac</span>
                <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">RF</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;fissionWidthA&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">comfac</span>
                <span class="n">elasticSum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">RN</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">comfac</span>
            
            <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="c"># common factor &#39;beta&#39; as row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">captureSum</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="p">(</span><span class="n">capture</span><span class="p">,</span><span class="n">elastic</span><span class="p">,</span><span class="n">fission</span><span class="p">):</span>
            <span class="n">reaction</span><span class="p">[</span> <span class="n">reaction</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>

        <span class="n">xscs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">}</span>

        <span class="c"># convert to crossSection.pointwise instances, using interpolation specified in the evaluation:</span>
        <span class="n">eInterp</span><span class="p">,</span> <span class="n">xsInterp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xscs</span><span class="p">:</span>
            <span class="n">axes_</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">pointwise</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">(</span> <span class="n">energyInterpolation</span><span class="o">=</span><span class="n">eInterp</span><span class="p">,</span> <span class="n">crossSectionInterpolation</span><span class="o">=</span><span class="n">xsInterp</span> <span class="p">)</span>
            <span class="n">xscs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">crossSection</span><span class="o">.</span><span class="n">pointwise</span><span class="p">(</span> <span class="n">axes_</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">xscs</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span> <span class="mf">0.001</span> <span class="p">)</span>
            <span class="n">xscs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">xscs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">xSlice</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">xscs</span>
</pre></div></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/gnd.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">Fudge and GND 1.2 beta documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, B.Beck, D. Brown, C. Mattoon, N. Patel, N. Summers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>